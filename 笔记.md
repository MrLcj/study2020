jvm

### 内存模型                                    

#### 	程序计数器

​		当前执行字节码的行号指示器，字节码指示器通过改变程序计数器的值来选取下一条需要执行的字节码指令。（分支、循环、跳转、异常）

#### 	虚拟机栈

​		栈帧：虚拟机栈是Java方法执行的内存模型，每个方法执行时都会产生对应的栈帧，储存局部变量表、操作数栈、动态链接、方法出口等信息。每个方法入栈到出栈的过程对应，从方法调用到执行完成的过程。

###### 		局部变量表

​			局部变量表是一组变量值存储空间，用于存放方法参数和方法内定义的局部变量，它的大小在方法的code属性的max_locals数据项中确定了需要分配局部变量表的最大容量。

​			局部变量表的最小单位是slot用来存放boolean、byte、char、short、int、float、reference（一种对象实例的引用）等类型的数据，并且都可以用32位或更小的物理内存来存放一个slot单位，slot的长度可以随着处理器、操作系统或虚拟机的不同儿发生变化，但是虚拟机仍然会使用对齐补白的方式让slot看起来与32位虚拟机中的一致。虚拟机通过索引定位的方式使用局部变量表，索引值的范围从0开始直到局部变量表的最大的slot数量，对于64位的数据类型则会以高位补齐的方式占用两个连续的slot空间，并且只允许同时访问这两个空间不允许单独访问其中一个。

​			在方法执行的时候，虚拟机使用局部变量表完成参数值到参数变量列表的传递过程，如果执行的是实例方法，局部变量表第一个0位索引的slot默认是用于传递方法所属实例的引用，可以用this进行访问，其余的参数按照参数表顺序排列。

​			局部变量表中的slot是可以复用的，方法体中定义的变量不一定会覆盖整个方法体，如果字节码计数	器的值超出了某个变量的作用域，这个变量对应的slot就可以换给其他变量使用。但是slot的复用会影响垃圾收集行为。当变量表未发生变化时，即使当前变量作用域已经不能访问，gc Roots一部分的变量表仍保持着关联所以不会对其进行垃圾回收，只要变量表产生变化slot被复用后才会被垃圾回收给gc了。

###### 		操作数栈

​			操作数栈是一个先进后出，后进先出的栈，和局部变量表一样，操作数栈的深度也是在编译的时候写入到code属性的max_stacks数据项中，操作数栈每个元素可以是Java任意数据类型，32位占用容量为1，64位占用为2，方法执行时深度不会超过max_stacks的值。当方法刚开始执行时操作数栈为空，方法在执行过程中，各种字节码指令会往操作数栈中读取和写入。也就是出栈和入栈的操作，在操作栈中元素时必须保持元素数据类型和字节码指令的序列严格匹配。

###### 		动态链接库 

​			栈针都有个一指向常量池的引用，有一部分是静态解析，就是类加载的时候已经讲符号引用转化为	直接引用，另外一部分需要动态引用，就是虚拟机在编译期不会讲符号引用转为直接引用而是在方法执行期	间进行动态链接引用。

###### 		方法返回地址

​			每个方法执行时有两种方法可以退出这个方法，第一种是正常返回——当方法接收到字节码返回指	令时有可能会向上层方法返回返回值，是否有返回值和返回值的类型根据接收到的返回指令来决定。第二种	是异常返回——在方法执行的过程中遇到了异常，并且这个方法在方法体内没有得到处理，不管是Java虚拟机内部的异常还是代码用athrow字节码指令产生的异常，只要在这个方法的异常表中没有搜索到匹配的异常处	理器都会导致方法退出，如果是异常退出方法，方法将不会给他的上层调用者产生任何返回值。

​			无论方法以哪种方式退出，其实都是等同于把当前栈帧出栈，并且退出时可能执行的操作有：恢复	上层方法的局部变量表和操作数栈，如果有返回值讲返回值压入调用者栈帧的操作数栈中，调整pc计数器的值以指向方法调用指令的后一个指令。			

#### 	Java堆

​		堆是虚拟机中最大的一块内存区域，里面存放着所有的对象实例，所有的对象实例都是在这里进行分	配。

#### 	本地方法栈

​		与虚拟机栈作用相似，区别只不过是本地方法栈中执行的是native方法服务，而虚拟机栈执行的是Java方法（实例方法）服务。

#### 	方法区

​		和堆一样是各个线程共享的内存区域，主要用来存放已被虚拟机加载的类信息、常量、静态变量即时编	译的代码等数据。为了与堆划分开也被称为非堆。

#### 	运行时常量

​		class文件除了有类的基本信息外还有一项信息：常量池，常量池用于储存编译过程中生成的各种字面量	和符合引用。

#### 	直接内存

​		虚拟机的缓冲内存区域，可以使用native函数库分配出来的堆外内存区域，作为堆内内存的引用进行操作

### GC原理

#### 	对象回收策略

​		在Java堆中存放着Java中所有的对象实例，当需要对内存进行垃圾收集时，我们首先需要确定这些对象中那些是还要使用的和那些是无用的对象（不能通过任何途径使用的对象）

##### 	可达性分析算法

​		可达性分析算法的基本思路就是一系列叫做gc Roots的对象作为起点，从这些起点通过引用链向下查	找，当一个对象到gc Roots没有任何一个引用链相连时，证明这个对象是不可用的，这个对象会判定为可回	收对象。

​		在Java中能作为gc Roots的对象包括一下几种：虚拟机栈中引用对象、方法区中类静态属性引用对象、方法区中常量的引用对象、本地方法栈中的native方法引用对象。

##### 对象引用级别

​		强引用：强引用是最普遍的引用级别，例如 Object  a= new Object()；直接引用实例对象地址。这样的引用只要引用存在，垃圾收集器就永远不会对对象进行标记回收。

​		软引用：软引用一般用于一些有用但非必要的对象，需要通过SoftReference类来实现，当可用内存不足将要发生内存溢出时，收集器才会将该类引用对象进行回收以释放一些内存防止发送内存溢出，如果释放的内存还是不够，依然还是会产生内存溢出。

​		弱引用：弱引用也是用来描述一些有用单非必要的对象，需要通过WeakReference类来实现，弱引用的对象只能存活到下一次垃圾收集器执行前，当下一次垃圾收集器执行时不论内存是否足够都会将弱引用的对象进行回收。

​		虚引用：虚引用是最弱的一种引用，需要通过PhantomReference类实现，这种被这种引用锁引用的对象不能通过引用获取到对象实例，作用仅仅是收集器在回收该对象时会发出一个系统消息提示将该对象回收了。

##### 对象最后的救赎

​		当对象第一次被垃圾收集器标记时（引用链与gc Roots 没有关联时），收集器不会第一时间将对象直接回收，而是将对象根据是否需要执行finalize()方法，当对象没有覆盖finalize()或者虚拟机已经调用过finalize()，虚拟机这两种情况都视为没必要执行直接回收对象。

​		当对象被认为有必要执行finalize()时，这个对象会被放进一个叫Q-queue的队列，并且会由虚拟机自动建立的 一个优先级较低的线程去执行这个队列，但是执行时为了防止队列中有方法执行较慢或是出现卡顿的情况，不管执行了多少，下一次回收执行时都会把这个队列没有没有执行完的回收，对象在这个队列也不一定就会被救活。

并且finalize()只会被执行一次，执行过后就会被标记为调用过finalize(),直接被收集器回收。

##### 回收方法区

​	在方法区进行垃圾收集的效率要比在堆中进行垃圾回收的效率更低很多,方法区的垃圾收集主要包含两部分内容,废弃的常量和无用的类。在回收废弃常量时与回收堆中相似。例如一个常量池的字面量，他已经在常量池中了，但是却没有任何对象实例引用这个字面量，也没有其他地方引用。如果这个时候发生垃圾收集，有必要的话这个字面量就会被清出常量池。常量池其他类、接口、方法、字段的引用也是类似这样。

​	判定一个常量是否是废弃常量比较直观，但是在判断一个类是否是废弃类时条件比较严格，需要同时满足：

​		该类所有的实力都已经被回收，也就是java堆中没有该类的任何实例。

​		加载该类的ClassLoader已经被回收。

​		该类对应的java.lang.Class对象没有在任何位置被引用，无法在任何地方通过发射访问该类的方法。

​	虚拟机可以对满足这三个条件的类进行回收，这是仅仅说的是可以而不是和对象一样没有用了就进行回收，是否对类进行回收虚拟机提供了参数-Xnoclassgc进行控制。另外在大量使用反射、动态代练、cglib等byteCode框架、动态生成jsp以及OSGi这类频繁定义classLoader的场景时都需要虚拟机具备卸载类的功能，以确保方法区不会溢出。

#### 垃圾回收算法

##### 标记-清除算法

​	标记-清除算法是最基础的收集算法，主要分为标记和清除两个阶段：首先先将需要回收的对象进行标记，在标记完成后统一回收所有标记对象。之说以说标记清除算法是最基础的收集算法，是因为后续的收集算法都是基于这个思路在对它的不足进行改进而得到的。它的不足主要有两个：一个是效率问题，标记和清除的效率都不高；另一个是空间问题，进行标记清除后会产生很多零散不连续的内存碎片，内存空间太多了有可能会导致后续需要分配一个较大内存的对象时，无法找到足够的连续内存而不得不再次提前触发另一次垃圾收集动作。

##### 复制算法

​	为了解决效率的问题，复制算法出现了，复制算法主要是将内存一分为二，变成两个内存相等的区域，每次只使用其中一块，当这块内存使用完时将还存活的对象复制到另一块内存上面，然后将已使用过的内存空间一次性清理掉，这样每次都是清理其中一整块的内存，在新分配时就不需要考虑内存碎片等问题，只要移动堆顶的指针，按顺序分配内存就行了，实现简单运行高效。只是这种算法代价是将内存缩小成了原来的一半。每次只使用一半。

##### 标记-整理算法

​	复制算法在对象存活率较高时会需要进行多次的复制操作，效率将会变低。更关键是如果不想浪费50%的空间，就需要有额外的担保分配空间，用来对内存中所有对象100%存活的极端情况，所以在老年代不能直接选用这种算法。

​	根据老年代的特点（对象存活率较高）提出了另一种收集算法“标记-整理”算法，同样标记阶段与标记清楚算法中的一样，但是后续步骤不是直接清除，而是让存活的对象都像一端移动，然后清除端边界以外的内存。

##### 分代收集算法

​	分代收集算法是根据对象存活周期的不同将内存划分为几块，一般是将java堆分为新生代和老年代，根据各年代对象存活周期不同使用适当的算法，在新生代中每次垃圾收集都有大批的对象死去，只有少量存活，所以使用复制算法，只要付出少量存活对象的复制成本就可以完成垃圾收集。而在老年代对象的存活率较高，没有额外空间对其进行分配担保，就需要使用标记-清除或者是标记-整理算法来进行垃圾回收。

#### hotSpot的算法实现

##### 枚举根节点

​	从可达性分析中GC Roots 节点找引用链这个操作为例，能作为GC Roots 的节点主要是在全局的引用（常量或静态类属性）和上下文（栈帧中的本地变量表）中，但是一个应用一个方法区就有数百兆，如果要注意检查引用，必然会消耗很多时间。

​	另外这个时间还体现在GC停顿上，因为这项分析工作必须是在能保持一致的进行，必须在同一个时间节点进行，不能出现在分析的同时对象引用还在不断变化的情况，不然将严重影响分析的结果准确性，所以在GC是必须停顿所有的java执行线程。

​	由于目前的主流java虚拟机使用的都是准确式GC，当执行系统停顿下来之后，并不需要一个个去检查所有的有执行上下文和全局的引用位置，虚拟机应当是有办法直接知道哪些地方存放着对象引用。在hotSpot的实现中，是使用一组成为OopMap的数据结构来达到这个目的，在类加载完的时候HotSpot就把对象内什么偏移量上面对应的是什么类型的数据计算出来，在Jit编译的时候也会在特定的位置记录下栈和寄存器中哪些位置是引用。然后Gc在扫描时就可以直接知道这些信息了。

##### 安全点

​	在OopMap的协助下，HotSpot可以快速准确的完成GC Roots 枚举，但是引用关系变化，或者说oopMap内容变化的指令非常多，如果每条指令都生成对应的oopMap，将会需要大量的额外空间，这样GC空间的成本就变得很高。

​	所以实际上Hotspot没有为每一个指令都生成oopMap，只会在特定的位置记录这些信息，这些位置被称为安全点，程序在执行时并不能任意一个地方进行停顿下来GC。只有到达安全点是才会暂停。安全点的选定既不能太少也不能让GC时间过长，也不能过于频繁导致运行时的负荷过大。安全点选定基本上是以：是否具有让程序长时间执行的特征。为标准进行选定。最明显的特征就是指令复用序列，例如方法调用、循环跳转、异常跳转等具有这些功能的指令才会产生安全点。

​	安全点的目的是为了生成OopMap完成Gc Roots 选举，当线程在执行时我们需要确认所有的线程都执行到最近的安全点后在停顿进行GC。一共有两种方式进行这个操作：

​	抢先式中断：在gc发生时，先把所有线程中断，如果发现有线程还未执行到安全点被中断，就恢复这个线程让他跑到安全点上。（很少使用）

​	主动式中断：当gc需要中断线程的时候，不对线程直接做操作，而是简单的设置一个标志，让线程执行时主动去轮询这个标志，发现中断标志为真时就直接挂起。轮询标志和安全点是重合的，另外在加上创建对象需要分配内存的地方。

##### 安全区域

​	使用安全点似乎已经很完美的解决了怎么样进入GC的问题了，但是实际情况仍是会有不确定的情况，安全点机制保证了程序在执行时，不需要很长的时间就可以进入到安全点，但是程序如果不执行时，线程是无法响应jvm的中断请求的，所谓不执行就是没有分配cpu时间，例如当线程处于sleep状态或者blocked状态，线程已经不执行了，自然没办法跑到安全的地方挂起，虚拟机也不可能等待线程被重新分配cpu时间，这种情况下就需要安全区域来解决。

​	安全区域是指在一段代码中引用关系不会发生变化，在这个区域任意位置开始GC都是安全的。在线程执行到安全区域中代码时，先会标识自己已经进入了安全区域，如果在这段时间里jvm要发起GC时，就不用管标识自己为安全区域状态的线程了。在线程离开安全区域时需要检查系统是否已经完成l 根节点选举，如果完成了就继续执行，如果没有他就需要收到可以安全离开安全区域的信号才能继续往下执行。

#### 垃圾收集器

​	如果说手机算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。在java虚拟机规范中对垃圾收集器应该如何实现没有任何规定，所以一般不同的垃圾收集器都可能有很大差别，并且会提供参数供用户根据自己应用的特点和要求组合出各个年代使用的收集器。

##### Serial收集器

​	Serial收集器是最基本、发展历史最悠久的收集器。这个收集器是一个单线程的收集器，他的单线程不仅仅是说它只会用一个收集线程去完成垃圾收集工作，更重要的是他在收集时必须暂停其他所有线程的执行，直到它收集完成。

​	Serial收集器虽然有着不可弥补的缺陷，但是目前它依然是虚拟机运行在client模式下的默认新生代收集器，它也有着优于其他收集器的地方：简单高效（对于其他单线程的收集器），对应限定单个cpu环境来说，Serial收集器没有线程交互的开销，专心做垃圾收集的工作自然可以获得最高单线程收集效率。

##### ParNew收集器

​	ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其他参数、收集算法对象分配规则、回收策略都与Seria收集器一致。

​	ParNew收集器除了多线程收集之外，其他与Serial收集器相比没有太多创新之处，但是它却是许多运行在server模式下的虚拟机首选收集器，与性能无关的原因是它能和CMS收集器配合工作。

​	ParNew收集器在单cpu环境下绝对不会有比Serial收集器效果更好的情况，因为ParNew收集器存在线程交互的开销。

##### parallel Scavenge 收集器

​	parallel Scavenge 收集器是一个新生代收集器，也是使用复制算法的收集器，又是并行的多线程收集器。它的特点是它的关注点和其他收集器不同，CMS等收集器的关注点是尽可能的缩短gc时用户线程的停顿时间，而parallel Scavenge 收集器的目的是达到一个可控制的吞吐量。

​	停顿时间越断就越适合需要与户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率利用cpu时间，尽快完成运算任务，主要适合在后台运算且不需要太多任务交互。parallel Scavenge 收集器提供了两个参数精准的控制吞吐量：

​	MaxGCPauseMaillis:允许值是一个大于0的毫秒数，收集器将尽可能保证回收内存花费的时间不超过设定值，但是并不是设置的越小内存回收时间越短，GC停顿时间的缩短是以牺牲吞吐量和新生代的空间来换取的，系统把新生代调小，这样就导致垃圾收集发生的更频繁一些，原本10秒收集一次、每次停顿100毫秒，现在变成每五秒收集一次，每次停顿70毫秒，停顿时间确实降低了，但是吞吐量也下降了。

​	GCTimeRatio：值是一个大于0且小于100的整数，意思是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。如果把参数设成19，那允许的最大GC时间就占总时间的5%（1/(1+19)），默认值为99，就是最大允1%的垃圾收集时间。

##### Serical old收集器

​	Serical old 收集器是Serial收集器的老年代版本，也是单线程的收集器，使用标记-整理算法。主要用于client模式下的虚拟机使用，在server模式下，主要有两个作用，第一：与parallel scavenge收集器搭配使用，另一种是作为cms收集器的后备预案，在并发收集发生Concurrent Mode  failure （CMS垃圾收集器特有的错误，CMS的垃圾清理和引用线程是并行进行的，如果在并行清理的过程中老年代的空间不足以容纳应用产生的垃圾，则会抛出“concurrent mode failure”）时使用。

##### parallel old收集器

​	parallel Scavenge 收集器老年代的版本，使用的是多线程和标记-整理算法。在注重吞吐量和cpu资源敏感时可以使用，parallel old收集器与parallel Scavenge收集器组合使用。吞吐量优先。

##### CMS收集器

​	CMS收集器是基于标记-清除算法的收集器，以获取最短回收停顿时间为目标的收集器，主要用于注重服务器响应速度，希望系统停顿时间最短，以给用户带来较好的体验的这类应用。

​	CMS收集器的运作过程比之前的几种收集器较为复杂一些主要分为四部分：

​		初始标记：仅仅是标记一下与GC Roots能直接关联的对象，速度很快（需要stop the world，单线程标		记）

​		并发标记：对GC Roots进行追踪标记（不需要stop the world ，可以与用户线程同时执行，耗时较长）

​		重新标记：修复并发标记期间因用户程序继续执行运作而导致标记产生变动的那部分对象的标记记录，		在执行时耗时会较长，但没有并发标记那么长（需要stop the world，并发标记）

​		并发清除：清除回收废弃对象，执行完成后会重置线程（不需要stop the world，与用户线程同时执行）

​		CMS是一款优秀的收集器，明显的优点：并发收集、低停顿。但是它也不是完美的，主要缺点有三点：

​	CMS收集器对cpu资源比较敏感，因为并发编程的程序都对cpu资源比较敏感，虽然说不会导致用户线程停顿，但是因为要占用一部分线程（cpu资源）导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是（cpu数量+3）/4,也就是在cpu数量在4个以上时，并发回收线程需要占用不少于25%的cpu资源，并随着cpu数量的增加而下降。但是当cpu不足4个时，比如两个cpu时，CMS收集器对程序影响可能变得很大，如果本来cpu负载很大还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度突然降低，为了应付这种情况，虚拟机提供了一种称为“增量式并发收集器”的CMS收集器变种，在并发标记、清理的时候让GC线程和用户现场交替运行，尽量减少GC线程独占资源的时间。这样垃圾回收的时间会边长，但是对用户程序的影响会减少一些。但是实际上增量时CMS收集器的效果很一般。

​	CMS收集器无法处理浮动垃圾，可能会出现Concurrent Mode  failure ，而导致另一次的重新Gc的产生。因为CMS在进行并发清理的时候用户线程还在运行，这样用户线程就会产生新的垃圾，这部分的垃圾是出现在标记过程之后，CMS无法在当次收集中处理它们，只能等下一次收集时在处理这部分垃圾，这部分垃圾被称为“浮动垃圾”。也是由于在垃圾收集期间用户线程还要执行所以CMS收集器不能像其他收集器那样等到老年代几乎被填满了在进行收集，需要预留一部分空间提供给并发收集器的程序使用。这个空间的比例可以根据参数-XX：CMSInitiatingOccupancyFraction来配置空间的百分比值。如果老年代增长速度太快导致，CMS运行期间预留的空间无法满足程序需要，就会出现一次Concurrent Mode  failure 失败，这个时候虚拟机就会启动后备方案：临时启用Serial old收集器来重新进行老年代的垃圾收集，这样停顿的时间就很长了。

​	还有最后一个缺点，CMS收集器使用的是标记-清除算法来实现的，就意味着收集完成后会有大量的空间碎片产生，空间碎片过多时，需要分配大对象时就会很麻烦,会出现老年代明明有很大空余空间，在需要分配大对象时却没有足够的连续空间来分配，导致提前触发下一次GC。CMS收集器提供了一个 -XX：+UseCMSCompactAtfullCollection开关参数（默认开启）用于在CMS收集器支撑不住要开始执行下一次Gc时开启内存碎片合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但是停顿时间会边长。虚拟机设计了另一个参数-XX：CMSFullGCBeforeCompaction，这个参数是用于设置执行多少次不压缩的GC后，进行一次带压缩的GC。（默认为0表示每次都进行碎片整理）

##### G1收集器

​	G1收集器一款面向服务端应用的垃圾收集器。与其他收集器比较有以下特点：

​	并行与并发：G1能充分利用多cpu、多核环境下的硬件优势，使用多个cpu来缩短 stop the world 停顿时间，部分部分其他收集器原本需要停顿java线程执行GC动作，G1收集器仍然可以通过并发的方式让java现场继续执行。

​	分代收集：和其他收集器一样分代概念在G1中得到保留。G1可以单独处管理整个GC堆，它可以采用不同的方式去处理新创建的对象和存活一段时间、熬过多次GC的旧对象以获取更好的收集效果。

​	空间整合：G1从整体看是基于标记-整理的算法来实现收集器，从局部区域上来看又是基于复制算法来实现的，但是无论如何，这两种算法都意味着G1运作期间不会产生空间碎片，手机后能提供规整的可用内存，这样的方式有利于程序长时间运行，分配大对象时不会因为无法找到连续空间而提前触发下一次GC。

​	可预测的停顿：这是G1相对于CMS的另一个优势点，G1和CMS的关注点都是降低停顿时间。但是G1除了追求低停顿外，还能建立可预测停顿时间模型，能让使用者明确在一个M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。几乎已经是实时java垃圾收集器的特征了。

​	使用G1收集器时，java堆的内存布局与其他收集器有很大差别，他将整个java堆划分成多个大小一致的独立区域，虽然还保留新生代和老年代的概念，但是他们不再是物理相隔了，它们都是一部分区域的集合。

​	G1收集器之所以能建立可预测的停顿模型，是因为他可以有计划的避免整个java堆中进行全局区域的垃圾收集。G1能跟踪各个区域里面的垃圾堆积价值大小（回收所获得的的空间大小和回收所需时间），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的区域。这样使用区域来划分内存空间及优先级的区域回收方式，保证了G1能在有限的时间里可以获取尽可能高的收集效率。

​	G1把内存化整为零的思路，理解起来似乎很容易，就是将内存分 成多个区域后，按照收集的效率的高地建立优先级。但是其实每个区域都不是独立的，一个对象分配在某个区域中，他并非只能被本区域的中的其他对象引用，而是可以和整个java堆任意对象发生引用关系，这时再做可达性分析判断对象是否存活的时候岂不得扫描整个java堆才能保证准确性？在所有的分代收集中都有这个问题，不同分代大小和收集的频率都不一样，在收集某个分代时都会面临这个问题，只是在G1收集器中比较突出。

​	在G1收集器中，区域之间对象的引用以及其他收集器中的新生代与老年代直接对象的引用，虚拟机都是使用Remembered Set  来避免全栈扫描，G1中每个区域都有一个对应的Remembered Set，当虚拟机发现线程在对Reference类型的数据进行写操作时，会产生一个 write  Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的区域之中（检查是否有老年代的对象引用新生代中的对象），如果是有的话，便通过CardTable把相关引用信息记录到被引用对象所属区域的Remembered Set 之中。 当进行回收时，在Gc根节点的枚举范围加入Remembered Set 就可以保证不对全堆扫描也不会有遗漏。

​	如果不计算Remembered Set 的操作，G1收集器的运作大概分为以下几个步骤：

​	初始标记：标记GC Roots能关联到的对象，修改Next top at Mark start 的值，让下一阶段用户程序并发运行时能在正确可用的区域创建对象。这阶段需要stop the world 时间很短。

​	并发标记：从GC Roots开始对堆中对象进行可达性分析，找出存活对象，这阶段耗时较长，但是可与用户线程并发执行。

​	最终标记：修正并发标记期间因用户程序继续执行导致标记产生变动那一部分标记记录，虚拟机将这段时间对象的变化记录在线程Remembered Set logs里面，然后将Remembered Set Logs的数据合并到Remembered Set 中，这个阶段需要暂停线程，但是可以并行执行。

​	筛选回收：首先将各个区域的回收成本和价值进行排序，然后在根据用户所期望的GC停顿时间来制订回收计划。这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收部分区域，时间是由用户可控制的，而且停顿线程将大幅提高收集效率。

### 类加载

##### 加载

​	在加载阶段，虚拟机需要完成以下三件事：

​		1.通过一个类的全限定名来获取此类的二进制字节流。

​		2.将这个字节流所代表的静态存储结构转化为方法区运行时数据结构。

​		3.在内存中生成这个类的java.lang.class对象，作为方法区这个类的各种数据访问入口。

##### 验证

​	验证是连接阶段的第一步。目的是为了确保Class文件的字节流中包含的信息符合虚拟机当前的要求，不会危害虚拟机的自身安全。验证一般分为：

###### 	文件格式验证

​	第一阶段要验证字节流是符合Class文件格式的规范，并且能被当前版本 虚拟机处理，只有通过了这个阶段验证后，字节流才会进入内存方法区中进行储存。主要有以下几个验证点：

​	1.是否是以魔数0xCAFEBABE开头。

​	2.主、次版本号是否在当前虚拟机处理范围。

​	3.常量池中是否有不被支持的常量类型（检查常量的tag标志）

​	4.指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。

​	5.CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据。

​	6.Class文件中各部分及文件本身是否有被删除的或附加的其他信息。

###### 	元数据验证

​	第二个阶段是对字节码描述的信息进行语义分析，以保证描述的信息符合java语言规范要求，主要包含以下验证点：

​	1.这个类是否有父类（除了java.lang.Object之外，所有的类都有父类，Object类是所有类的父类）

​	2.这个类的父类是否继承了不允许被继承的类（被final修饰的类）

​	3.如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。	

​	4.类中的方法、字段是否与父类产生矛盾（例如覆盖了父类的final字段，出现不合规则的重载）

###### 	字节码验证

​	字节码验证是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法、符合逻辑的。这个阶段会对类的方法体进行校验分析，保证被校验类方法不会对虚拟机做出危害的事件,例如：

​	1.保证任意时刻操作数栈的数据类型和指令代码序列都能配合工作，不会出现类似在操作数栈存放一个int类型的数据，使用时却安装long类型加载到本地变量表。

​	2.保证跳转指令不会跳转到方法体以外的字节码指令上。

​	3.保证方法中的类型转换是有效的，比如把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与他毫无继承关系、完全不相干的一个数据类型，这都是不合法的。

###### 符号引用验证

​	符号引用验证是验证的最后一个阶段在虚拟机将符号引用转化为直接引用的时候，这个阶段连接着解析阶段发生。符号引用验证是对类自身以为常量池中的各种符号引用的信息进行匹配性校验，通常需要校验：

​	1.符号引用中通过字符串描述的全限定名是否能找到对应的类。

​	2.在指定的类中是否存在符合方法的字段描述符和简单名称所描述的方法和字段。

​	3.符号引用中的类、字段、方法的访问性是否可以被当前类访问

##### 准备

​	准备阶段是正式为类变量分配内存并设置初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。但是在这个时候进行内存分配的变量仅包括类变量（被static修饰的变量），不包括实例变量，实例变量将会随对象实例化时随着对象一起在java堆中分配，这里说的初始值是指数据类型的零值。

##### 解析

​	解析是虚拟机将常量池中的符号引用替换为直接引用的过程。

​	符号引用：符号引用是一组符号来描述所引用的目标.符号可以是任何形式的字面量，只要能无歧义的定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中，各种虚拟机实现的内存布局不同，但是他们能接收的符号引用必须都是一致的，因为符号引用的字面量形式明确的定义在java虚拟机规范的Class文件格式中。

​	直接引用：直接引用可以是直接指针指向目标的指针、相对偏移量或一个能间接定位目标的句柄。直接引用跟虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有直接引用，那这个引用的目标必定已经存在内存当中。

###### 类或接口解析

​	类的解析是将一个类的符号引用变为指向InstanceKlass对象的直接指针。指向这个对象的开头， 当创建对象的时候，这个指针会赋值给对象头中_kclass指针。 这样就定位到了该类的数据。访问类的元数据信息，是通过描述该类的类的对象实现的，当然 每个类只对应一个InstanceKlass对象。这就是类本身如何被描述的内存形态。

​	因为对象内部的数据在内存中的连续堆放的，当你访问一个类的某字段，是需要通过元数据InstanceKlass对象 来记录这个字段的与对象头的偏移量来获取。 当然调用对象的方法是定位到虚方法表 而不是定位到对象的内存区域，创建对象其实就是仅仅向一块内存区域写入与类元数据对应的各种字段的值，当然对象类型的值是一个引用，访问一个对象的字段的值， 是通过定位这个字段在这个对象起始地址的相对偏移量。确定相对偏移量就是在字段解析阶段完成的。

###### 字段解析

​	字段的解析是确定一个对象的字段的访问地址，是计算相对对象起始地址的偏移量。当第一次用getfield指令访问一个字段，字段的fieldref常量会最终解析成偏移量信息，放入cpc中，然后指令会被修改成fast_bgetfield来避免重复解析而是直接使用偏移量 以使用正确的类型 来访问字段。

###### 方法解析

​	这里单独从元组jvm来分析 就是生成一个描述元数据的methodtable结构体。类似虚方法表。每一个类加载后，会对应一个虚方法表。当第一次调用方法时，也就是执行invokevirtual指令，指令参数为 该方法的符号引用（包含了参数个数和类型信息，返回值类型，这样就区分了方法重载是不同的方法），也就是对应找到常量表中的methodref类型的项。（class文件中不同类型的项都有标记来标识，从而能够描述并得到这个的项的内部结构 而取到对应的值）。

##### 初始化

 	初始化是类加载的最后一步，在前面的阶段中，除了在加载阶段用户应用程序可以通过自定义类加载器之外，其余动作都是由虚拟机主导和控制。到了初始化阶段才是真正执行类中定义的java程序代码。

#### 类加载器

##### 类与类加载器

​	类加载器虽然只用于实现类加载动作，但是在java程序看来远远不限于类加载阶段，对于任意一个类都需要由加载他的类加载器和这个类本身一同确立他在java虚拟机中的唯一性，每个类加载器，都拥有一个独立的类名称空间，通俗一点的说就是：比较两个类是否相等,只有在这两个类是同一个类加载器加载的前提下才有意思，否则这两类即使来源是同一个Class文件，被同一个虚拟机加载，只要他们的类加载器不同，他们就必不相等。

​	这里所指的“相等”，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用instanceof关键字做对象所属判定关系等情况。

##### 双亲委派模型

​	从java虚拟机的角度来讲，只存在两种不同的类加载器：一类是虚拟机自带的启动类加载器，另一类就是所有其他的类加载器，这些类加载器都是由java语言实现的，独立于虚拟机外部，并且都继承自抽象类java.lang.ClassLoader。

​	但是从java开发人员的角度来看，类加载器还可以划分的更细一些，大部分的java程序都会用到一下三种系统提供的类加载器：

​	1.启动类加载器（Bootstrap ClassLoader）虚拟机自带加载器，负责加载存放在<JAVA_HOME>\lib目录中的，或被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别）类库加载到虚拟机中，启动类加载器不能被java程序直接引用，用户在编写类加载器时，如果需要把类加载请求委派给引导类加载器，直接使用null代替即可。

​	2.扩展类加载器（Extension Classloader）：这个类加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载<JAVA_HOME>\lib\ext目录中的，或者是被java.ext.dirs系统变量所指定路径中的所有类库，开发者可以直接使用扩展类加载器。

​	3.应用类加载器（application classLoader）：这个类加载器是有sun.misc.Launcher$App-ClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值。所以一般被称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，可以直接使用这个类加载器，如果没有自定义类加载器一般情况下默认就是这个类加载器。

​	自定义类加载器------->应用程序类加载器--------->扩展类加载器---------->启动类加载器

 	双亲委派模型的工作过程是：如果一个类加载琦收到了加载类的请求，它首先不会自己去尝试加载这个类，而是把这个加载请求委派给父类加载器去完成，每个层次的类加载器就是这样，因此所以类加载的请求最终都会传送到顶层的启动类加载器中，只有父类反馈无法完成这个请求时，子类加载器才会尝试自己去加载。



# 多线程

![img](https://images0.cnblogs.com/blog/497634/201312/18152411-a974ea82ebc04e72bd874c3921f8bfec.jpg)

### 线程实现Thread和Runnable

​	Runnable是一个接口，并且接口中只包含了一个run()方法，Runnable实现多线程通过定义一个A类实现Runnable接口；然后通过呢我 Thread(new A())的方式实现新建线程。

​	Thread是一个类，本身就实现了Runnable接口，创建时只需要继承Thread类调用run()方法。

​	Thread和Runnable都是实现多线程的方式，Thread是类而Runnable是接口，Thread本身是实现了Runnable接口的类。一个类只能有一个父类，但是却能实现多个接口，因此Runnable具有更好的扩展性，

​	此外，**Runnable还可以用于“资源的共享”。即，多个线程都是基于眸一个Runnable对象建立的，他们会共享Runnable对象上的资源，所以一般建议通过Runnable实现多线程**。

### Thread中start()和run()的区别

​	start()：它的作用是启动一个新线程，新线程会执行相应的run();start()不能被重复调用。

​	run()：run()就和普通的成员方法一样，可以被重复调用。单独调用run()的话，会在当前线程中执行run()，而不启动新线程。

Thread.java中start()方法的源码如下：

```java
public synchronized void start() {
    // 如果线程不是"就绪状态"，则抛出异常！
    if (threadStatus != 0)
        throw new IllegalThreadStateException();

    // 将线程添加到ThreadGroup中
    group.add(this);

    boolean started = false;
    try {
        // 通过start0()启动线程
        start0();
        // 设置started标记
        started = true;
    } finally {
        try {
            if (!started) {
                group.threadStartFailed(this);
            }
        } catch (Throwable ignore) {
        }
    }
}
```

**说明**：start()实际上是通过本地方法start0()启动线程的。而start0()会新运行一个线程，新线程会调用run()方法。

```java
private native void start0();
```

Thread.java中run()的代码如下：

```java
public void run() {
    if (target != null) {
        target.run();
    }
}
```

**说明**：target是一个Runnable对象。run()就是直接调用Thread线程的Runnable成员的run()方法，并不会新建一个线程。

### 并发基础

#### 可见性

​	可见性是值线程之间的可见性，一个线程修改的状态对另一个线程是可见的,也就是一个线程修改的结果，另一个线程马上就能看到。使用关键字volatile修饰的变量就会具有可见性。

#### 原子性

​	原子是世界上最小的单位，具有不可分割性，例如：a=0；（a不是long也不是double）这个操作是不可分割的。在例如：a++;这个操作实际上是a=a+1；是可分割的，所以他不是一个原子操作，非原子操作都会存在线程安全问题，要将一个非原子操作变成原子操作需要用到同步关键字修饰Synchronize来让它变为一个原子操作，一个操作是原子操作，我们一般称它具有原子性。

#### 有序性

​	Java 提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。

### cpu cache结构

#### cache 的意义

​	cpu在一段较短的时间内，是对连续地址的一段很小的主存空间频繁的进行访问，而对此范围以外的访问甚少，这种现象称为程序访问的局部性。

高速缓冲存储器（Cache）技术就是利用程序访问的局部性原理，把程序中正在使用的部分（活跃块）存放在一个小容量的高速Cache中，使CPU的访存操作大多针对Cache进行，从而解决高速CPU和低速主存之间速度不匹配的问题，使程序的执行速度大大提高。

#### 寄存器

​	寄存器是中央处理器内的组成部分，寄存器是有限存贮容量的高速存贮部件，他们可用来暂存指令、数据和位置。寄存器是cpu内部的元件，寄存器拥有非常高的读写速度，所以在寄存器之间的数据传送非常快。

#### cache

​	高速缓存储器，是位于cpu与内存间的一种容量较小但数度很高的存储器。由于cpu的速度远高于主内存，cpu直接从内存中取数据需要等待一定时间周期，cache中保存着cpu刚用过或循坏使用的一部分数据，当cpu再次使用该部分数据时可以直接从cache中直接调用，这样就减少了cpu的等待时间，提升系统效率。

大致来说数据通过内存-cache-寄存器，Cache缓存则是为了弥补CPU与内存之间运算速度的差异而设置的的部件。

##### 原理

​	cpu与cache之间的数据交换是以字为单位的，而cache与原子性主存之间的数据交换则是以块为单位的。一个快由若干个定长字组成。

​	当CPU读取主存中的一个字时，该字的主存地址被发给Cache和主存，此时，Cache控制逻辑依据地址判断该字当前是否存在于Cache中：若在，该字立即被从Cache传送给CPU；若不在，则用主存读周期把该字从主存读出送到CPU，同时把含有这个字的整个数据块从主存读出送到Cache中，并采用一定的替换策略将Cache中的某一块替换掉，替换算法由Cache管理逻辑电路来实现。

##### cache line 结构

​	整个Cache被分成多个Line，每个Line通常是32byte或64byte ，Cache Line是Cache和内存交换数据的最小单位。

![img](https://raw.githubusercontent.com/ExplorerMan9527/image/master/CPU%E7%BC%93%E5%AD%98%E4%BA%A4%E6%8D%A2%E5%9B%BE.png)

​	每个Cache Line包含三个部分Valid：当前缓存是否有效Tag：对应的内存地址Block：缓存数据

![img](https://raw.githubusercontent.com/ExplorerMan9527/image/master/CPU%E7%BC%93%E5%AD%98%E8%A1%8C%E7%BB%93%E6%9E%84%E5%9B%BE.png)

##### cpu cache 与cpu main memory（主存）交互

​	Cache与主存都分成块(常常将Cache块说成Cache行)，每块由多个字节组成，大小相等。在一个时间段内，Cache的某块中放着主存某块的全部信息，即Cache的某一块是主存某块的副本(或叫映像)

地址映射是指某一数据在内存中的地址与在缓存中的地址两者之间的对应关系。下面介绍三种地址映射的方式。

###### 全相连映射

​	全相联映射是指主存中任意一个块都可以映射到Cache中任意一个块的方式，也就是说，当主存中的某一块需调入Cache时，可根据当时Cache的块占用或分配情况，选择一个块给主存块存储，所选的Cache块可以是Cache中的任意一个块。

![img](https://raw.githubusercontent.com/ExplorerMan9527/image/master/%E5%85%A8%E8%BF%9E%E6%98%A0%E5%B0%84%E5%9B%BE.png)

​	当一个主存块调入Cache中时，会同时在一个存储主存块号和Cache块号映射表的相联存储器中进行登记。CPU访存时，首先，根据主存地址中的主存块号M在相联存储器中查找Cache块号C，若找到，则本次访Cache命中，于是将对应的Cache块号取出，并返回Cache地址的块号C字段，紧接着将主存地址的块内字号W直接送Cache地址的块内字号W字段，从而形成一个访Cache的地址，最后根据该地址完成对Cache单元的访问。

优点：命中率比较高，Cache存储空间利用率高。

缺点：相联存储器庞大，比较电路复杂，访问相关存储器时，每次都要与全部内容比较，速度低，成本高，因而只适合于小容量的Cache之用，应用少。

######  直接相连映射

​	直接相联映射方式是指主存的某块j只能映射到满足如下特定关系的Cache块i中：

i＝j mod 2C

![img](https://raw.githubusercontent.com/ExplorerMan9527/image/master/%E7%9B%B4%E8%BF%9E%E6%98%A0%E5%B0%84%E5%9B%BE.png)

######  组相联映射

​	下面我们就来看看组相联映射方式在这种方式下，将Cache分成2u组，每组包含2v块。主存的块与Cache的组之间采用直接相联映射，而与组内的各块则采用全相联映射。也就是说，主存的某块只能映射到Cache的特定组中的任意一块。主存的某块j与Cache的组k之间满足如下关系：

k＝j mod 2u 设主存共有2s×2u块（即M＝s+u），则它们的映射关系如下图所示。

![img](https://raw.githubusercontent.com/ExplorerMan9527/image/master/%E7%BB%84%E7%9B%B8%E8%BF%9E%E6%98%A0%E5%B0%84%E5%9B%BE.png)

##### cache替换策略

​	为了在高数缓存未命中时为新条目腾出空间，高速缓存可能必须逐出现有条目之一，用于选择逐出条目启发方式称之为替换策略。任何替换策略的根本问题在于它必须预测将来最不可能使用那个现有缓存条目，预测未来很困难，隐藏没有完美的方法可以选择各种可用的替代政策。一种流行的替换策略，最近最少使用，替换最近少访问的条目。

​	将一些内存范围标记为不可缓存可以通过避免缓存很多重新访问的内存区域来提高性能，这避免了在没有任何重用的情况下将某些内容加载到缓存中的开销。也可以根据上下文禁用货锁定缓存条目。

主要算法如下：

###### 随机法（RAND法）

​	随机法是随机地确定替换的存储块。设置一个随机数产生器，依据所产生的随机数，确定替换块。这种方法简单、易于实现，但是命中率比较低。

###### 先进先出法（FIFO发）

​	先进先出法是选择那个最先调入的那个块进行替换。当最先调入并被多次命中的快，很可能被优先替换，因而不符合局部性规律。这种方法的命中率比随机法好些，但是还不满足要求。先进先出方法易于实现，例如Solar-16/65机cache采用组相联方式，每组4快，每块都设定一个两位数的计数器，当某块被装入或被替换时该块的计数器清0，而同组的其它块计数器各加1，当需要替换时就选择计数器值最大的快被换掉。

最近最少使用法（LRU法）

​	LRU法是依据各块使用的情况，总是选择那个最近最少使用的块被替换，这种方法较好的反映了程序局部性规律。

##### cache写策略

​	如果将数据写入高速缓存，则必须将其写入主存储器；这种写入的事件称为写入策略。**在直写高速缓存中，每次写入高速缓存都会导致写入主存器。在而回写高速缓存中，写入不会立即镜像到主存器，二手高速缓存会跟踪已写入的位置，将它们标记为脏，只有当数据从缓存中逐出时，这些位置的数据才会写回主存储器。**由于这个原因，回写高速缓存中的读取未命中有时可能需要两次服务器存储器访问：一次首先将脏位置写入主存储器，另一次从存储器读取新位置。此外，对尚未映射在回写高速缓存中的主存器位置的写入可以驱逐已经脏的位置，从而为新的存储器位置释放高速缓存空间。

​	还有中间政策。高速缓存可以是直写的，但是写入可以暂时保存在存储数据队列中，通常可以以前处理多个存储。（这样可以减少总线周转并提高总线利用率）。

来自主存储器的高速缓存数据可能被其他实体（例如，使用直接存储器访问（DMA）的外围设备货多核处理器中的另一个核心）改变。在这种情况下，高速缓存中的副本可能变得过时或超时。或者，当多处理器系统中的cpu更新高速缓存中的数据时，与其他cpu关联的高速缓存中的数据副本将变得陈旧。保持数据一致的高速缓存管理器之间的通信协议称为高速缓存一致性协议。

##### 缓存一致性协议

​	缓存一致性协议有多种，但是常见的大多数计算机设备使用的都属于“窥探（snooping）”协议，还有一种叫“基于目录的（directory-based）”协议，这种协议的延迟性较大，但是在拥有很多个处理器的系统中，它有更好的可扩展性。

​	“窥探”背后的基本思想是，所有内存传输都发生在一条共享的总线上，而所以的处理器都能看到这条总线：缓存本身都是独立的，但是内存是共享资源，所有的内存访问都要经过仲裁（arbitrate）：**同一个指令周期中，只有一个缓存可以读写内存。窥探协议的思想是，，缓存不仅仅在做内存传输的时候才和总线打交道，而是不停的窥探总线上发生的数据交互，跟踪其他缓存在做什么，所以当一个缓存代表它锁属的处理器去读写内存时，其他处理器都会得到通知，它们以此来使自己的缓存保持同步。只要某个处理器一写内存，其他处理器马上就知道这块内存在他们自己的缓存中对应的段已经失效**。

​	在直写模式下，这是很直接的，因为写操作一旦发生，它的效果马上会被公布出去。但是如果换成回写模式，就有问题了。因为有可能在写指令执行过后很久，数据才会被真正回写到物理内存中------在这段时间内，其他处理器的缓存也可能会傻乎乎地去写同一块内存地址，导致冲突，在回写模型中，简单把内存写操作的信息广播给其他处理器是不够的，我们需要做的是，在修改本地缓存之前告诉其他处理器。搞懂了细节，就找到了处理回写模式这个问题的最简单方案，我们通常叫做**MESI协议**代表着缓存的四种状态。

##### MESI协议

​	MESI是四种缓存段状态的简称，任何多核系统中的缓存段都是处于这四种状态之一。

①.**已修改（Modified）缓存段**，属于脏读段，它们已经被所属的处理器修改了，如果一个段处于已修改状态，那么它在其他处理器缓存中的副本马上会变成失效状态，这个规律和独占段状态一样，此外，已修改缓存段如果被丢弃或标记为失效，那么先要把它的内容写回到内存中-----和回写模式下常规的脏段处理方式一样。

②.**独占（Exclusive）缓存段**，与共享缓存状态一样，也是和主内存内容保持一致的副本，区别在于，如果一个处理器持有量某个独占状态的缓存段，那么其他处理器就不能同时持有它，所以叫独占。这就意味着如果其他处理器原本也持有同一个缓存段，那么它马上会变成“失效”状态。

③.**共享（Shared）缓存段**，它是和主内存内容保持一致的一份拷贝，在这种状态下的缓存段只能被读取，不能被写入。多组缓存可以同时拥有针对同一内存地址的共享缓存段，这就是名称的由来。

④.**失效（Invalid）缓存段**，要么已经不在缓存中，要么它的内容已经过时。为了达到缓存的目的，这种状态的段将会被忽略。一旦缓存段被标记为失效，那效果就等同于它从来没被加载到缓存中。

MESI协议是一个合适的状态机，技能处理来自本地处理器的请求，也能把信息广播到总线上：

​	⒈在多核系统中，读取某个缓存段，在实际上会牵涉到和其他处理器的通讯，并且可能导致它们发生内存传输。写某个缓存段需要多个步骤：在写任何东西之前，首先需要获得独占权，和所有请求的缓存段的当前内容拷贝（所谓的“带权限获取的读（Read For Ownership）请求”）。

​	⒉尽管我们为了一致性问题做了很多额外的工作，但是最终结果还是非常有保证的，即它遵守了以下定理：

​	**在所有的脏缓存段被回写后，任意缓存级别的所有缓存段中的内容和他们对应的内存中的内容一致。此外在任意时刻，当某个未组队内存被一个处理器加载入独占缓存段时，那它就不会出现在其他任何处理器的缓存中。**

### AQS

​	AQS是AbstractQueuedSynchronize的简称，AQS提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器框架。AQS为一系列同步器依赖与一个单独的原子变量（state）的同步器提供了一个非常有用的基础。子类们必须定义改变state变量的protected方法，这些方法定义了state是如何被获取或释放的，本类中的其他方法执行所有的排队和阻塞机制。子类也可以维护其他的state变量，但是为了同步必须都是原子操作这些变量。

​	AbstractQueuedSynchronize中对state的操作都是原子的，且不能被继承。**所有的同步机制的实现均依赖于对改变量的原子操作**。为了实现不同的同步机制，我们需要创建一个非共有的扩展了AQS类的内部辅助类来实现相应的同步逻辑。

​	AbstractQueuedSynchronize是一个抽象类，主要通过继承的方式使用，它提供了一些可以被具体实现类直接调用的一些原子操作方法来重写相应的同步逻辑，提供了互斥模式（exclusive）和共享模式（shared）两种不同的同步逻辑，一般情况下，子类只需要根据需求实现其中一种模式，当然也有同时实现两种模式的同步类，如ReadWriteLock。

#### state状态

​	AbstractQueuedSynchronize维护了一个volatile int类型的变量，表示当前同步的状态。volatile虽然不能保证操作原子性，但是保证了当前变量state的可见性。

- getState()
- setState()
- compareAndSetState()

#### 自定义资源共享方式

​	AQS定义两种资源共享方式：

​	Exclusive：独占、只有一个线程能执行

​	Share：共享，多个线程可同时执行

​	不同的自定义同步器争用共享资源的方式也不同，自定义同步器在实现时只需要实现共享资源state的获取和释放即可，至于具体线程等待队列的维护（如何获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了，自定义同步器实现时主要实现一下几种方法：

等待队列：**等带队列是用于存放等待获取锁的线程，当线程获取资源失败的时候，会被挂起在等待队列的尾部，队列以CAS的方式自旋去获取资源，等到资源释放时它会重新尝试获取资源，如果获取成功则唤醒线程继续执行，如果获取资源还失败则继续挂起。**

isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。

tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。

tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。

tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。

tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false

### CAS

​	CAS ：compare and Swap 比较并交换，java.util.concurrent包中借助CAS实现了区别于synchronize同步锁的一种乐观锁。

​	CAS有三个操作数，内存值V，就得预期值A，要修改的新值B，并且只有在预期值A和内存值V相同时，才将内存值修改为B，否则什么都不做。

​	**先说一下cas 如果内存中的值，等于程序中传入得期望值，就把内存的值修改为期望的值，实质上就是一个乐观锁的思路，然在juc下面把锁的状态比如state字段，每个线程在竞争锁的时候，都通过cas去修改这个state字段，修改成功的获取锁，修改失败的循环去获取这个锁**

​	非阻塞算法：一个线程的失败或者挂起不应该影响其他线程的失败或挂起的算法。

### Volatile

#### 线程间可见

​	保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。

原理：

###### 通过在总线加LOCK#锁方式

​	在早期的cpu当中是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为cpu和其他部件进行通信是通过总线来进行的，如果对总线加LOCK#锁的话，也就是阻塞了其他cpu对其他访问部件（如内存）。从而使得只能有一个cpu能使用这个变量的内存。例如：如果一个线程在执行i=i+1，如果在执行这段代码的过程中，在总线上发出了LOCK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他cpu才能从变量i所在内存兑取变量，然后进行相应的操作，这样来解决缓存不一致的问题，但是这样会导致频繁的锁住总线，其他cpu无法访问内存，导致效率低。

###### 通过缓存一致性协议

​	MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。**参考上面CPU CACHE结构中的缓存一致性协议**

#### 禁止指令重排

###### 内存屏障是什么

硬件层的内存屏障分为两种：

- Load Barrier 读屏障
- Store Barrier写屏障。

内存屏障有两个作用：

- 阻止屏障两侧的指令重排序；
- 强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。

**对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据，对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。**

###### **内存屏障组合分类**

如下图

![img](https://raw.githubusercontent.com/ExplorerMan9527/image/master/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E7%BB%84%E5%90%88%E5%88%86%E7%B1%BB%E5%9B%BE.png)

java的内存屏障通常所谓的四种即LoadLoad,StoreStore,LoadStore,StoreLoad实际上也是上述两种的组合，完成一系列的屏障和数据同步功能。

- LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。
- StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。
- LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。
- StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能

### Synchronize

#### 基本使用

​	Synchronize是Java中解决并发问题的一种最常用方法，也是最简单的一种方法。Synchronize的作用主要有三个：

​	①.原子性：确保线程互斥的访问同步代码；

​	②.可见性：保证共享变量的修改能够即使可见，实际是通过Java内存模型中的“**对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行LOCK操作，则将会清空工作内存中此变量值，在执行引擎使用此变量前，需要重新到主存中load操作或assign操作初始化变量值”**来保证；

​	③.有序性：有效解决重排序问题，**当“一个unlock操作先行发生于后面对同一个锁的lock操作”**；

从语法上讲。Synchronize可以把任何一个非null对象作为“锁”

Synchronize共有三种用发：

​	1.当Synchronize作用在实例方法时，监视器锁便是对象的实例（this）；

​	2.当Synchronize作用在静态方法时，监视器锁便是对象的Class实例，因为Class数据存在于永久代，因此静态方发锁相当于该类的一个全局锁；

​	3.当Synchronize作用在某个对象实例时，监视器锁便是括号括起来的对象实例；

​	**注意**Synchronize内置锁是一种对象锁（锁的是对象而非引用变量），作用粒度是对象，可以用来实现对**临界资源的同步互斥访问**，是可重入的，**可重入最大的作用就是避免死锁**，如：子类同步方法调用了父类同步方法，如果没有可重入特性，就会发生死锁。

#### 同步原理

​	数据同步需要依赖锁，关于锁Synchronize是在软件层面依赖jvm实现锁同步，而j.u.c.Lock是通过硬件层面依赖特殊的cpu指令实现锁同步。

​	当一个线程访问同步代码块时，**首先需要得到锁才能执行同步代码，当退出或者抛出异常时必须要释放锁**：

**monitorenter（监控者）**：每个对象都是一个监视器锁。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权限，过程：

​	①.如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者；

​	②.如果线程已经占用了monitor，只是重新进入，则进入数加1；

​	③.如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权限；

**monitorexit（监控退出）**：执行monitorexit的线程必须是Objectref所对应的monitor的所有者，**指令执行时，monitor的进入数减1，如果减1后进入数为0，则线程退出monitor，不再是这个monitor的所有者。**其他被这个monitor阻塞的线程可以尝试去获取这个monitor的所有权。monitorexit指令出现了两次，第一次为同步正常退出释放锁；第二次为发生异步退出释放锁；

synchronize的意义底层是通过一个monitor的对象来完成同步。其实wait/notify等等方法也是依赖于monitor对象，这也是为什么只有在同步的快或方法中才能调用wait/notify等方法，否则会抛出**java.lang.IllegalMonitorStateException**的原因。

**ACC_SYNCHRONIZED(标识符)**：方法的同步除了通过指令monitorenter和monitorexit来完成，还可以根据其常量池中的ACC_SYNCHRONIZED标识符。jvm可以根据该标识符来实现方法同步：**当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法体执行完后再释放monitor。在方法执行期间，其他任何线程都无法获得同一个monitor对象。**

这两种同步方式本质上没有区别，只是方法的同步是一种隐式的方式来实现，不需要通过字节码来完成。**两个指令的执行是jvm通过调用操作系统的互斥原语mutex来实现，被阻塞的线程会被挂起，等待重新调度**，会导致“用户态和内核态”两个态之间来回切换，对性能有较大影响。

#### 同步概念

##### java对象头

![img](https://user-gold-cdn.xitu.io/2018/7/29/164e3637df80c2a2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

​	synchronize用的锁就是存在Java对象头里的Mark Word（标记字段）中，Mark Word用于存储对象自身的运行时数据，是实现轻量级锁和偏向锁的关键。

​	Mark Word是一个非固定的数据结构以便在极小的空间内存存储尽量多的数据，它会根据对象的状态复用自己存储空间，也就是说它会随着程序的运行发生变化，可能变化为存储以下四种数据：

![Mark Word可能存储4种数据](https://user-gold-cdn.xitu.io/2018/7/27/164dacca5774da87?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

​	对象头的最后两位存储了锁的标志位，01是初始状态，未加锁，其对象头里存储的是对象本身的哈希码，随着锁级别的不同，对象头里存储不同的内容**。偏向锁存储的是当前占用此对象的线程ID**；**而轻量级则存储指向线程栈中锁记录的指针**。从这里我们可以看到，“锁”这个东西，**可能是记录锁记录和对象头里的引用指针**（判断线程是否拥有锁时将线程的锁记录地址和对象头里的指针地址比较），**也可能是对象头里的线程ID**（判断线程是否拥有锁时将线程ID和对象头里存储的线程ID比较）

##### Mark Word与线程中Lock Record（锁记录）	

​	在线程进入同步代码块的时候，**如果此同步对象没有被锁定，即它的锁标志位是01，则虚拟机首先在当前线程的栈中创建我们称之为“锁记录”的空间，用来存储锁对象的Mark Word的拷贝，整个MarkWord及其拷贝至关重要。**

​	Lock Record 是线程私有的数据结构，**每个线程都有一个可以用的Lock Record列表，同时还要一个全局的可用列表。每一个被锁住的对象MarkWord都会和一个Lock Record关联**（**对象头的MarkWord中的Lock Word指向Lock Record的起始地址**），同时Lock Record中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。

Lock Record的内部结构：

| Lock Record | 描述                                                         |
| ----------- | ------------------------------------------------------------ |
| Owner       | 初始时为NULL表示当前没有任何线程拥有该monitor record，**当线程成功拥有该锁后保存线程唯一标识**，当锁被释放时又设置为NULL； |
| EntryQ      | 关联一个系统互斥锁（semaphore），**阻塞所有试图锁住monitor record失败的线程**； |
| RcThis      | **表示blocked或waiting在该monitor record上的所有线程的个数**； |
| Nest        | 用来实现 **重入锁的计数**；                                  |
| HashCode    | 保存从对象头拷贝过来的HashCode值（可能还包含GC age）。       |
| Candidate   | 用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。**Candidate只有两种可能的值0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁**。 |

##### 监视器（Monitor）

​	任何一个对象都有一个Monitor与之关联，当且一个Monitor被持有后，它将处于锁定状态。synchronize在JVM里的实现都是**基于进入和退出Monitor对象来实现方法同步和代码块同步**，虽然具体实现细节不一样，但是都可以通过对MonitorEnter和MonitorExit指令来实现。

```
MonitorEnter指令：插入在同步代码块的开始位置，当代码执行到该指令时，将会尝试获取该对象Monitor的所有权，即尝试获得该对象的锁；

MonitorExit指令：插入在方法结束处和异常处，JVM保证每个MonitorEnter必须有对应的MonitorExit；
```

​	**Monitor可以把它理解为一个同步工具，也可以描述为一种同步机制，通常被描述为一个对象。**

与一切皆对象一样，所有的java对象是天生的Monitor，每个Java对象都有成为Monitor的潜质，因为在Java的设计中，**每个java对象创建出来就带了一把看不见的锁，它叫做内部锁或者是Monitor锁。**

也就是通常说synchronize的对象锁，MarkWord锁标识为为10，其中指针指向的是Monitor对象的起始地址。在虚拟机中，Monitor是由ObjectMonitor实现的，主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的）：

```
ObjectMonitor() {
    _header       = NULL;
    _count        = 0; // 记录个数
    _waiters      = 0,
    _recursions   = 0;
    _object       = NULL;
    _owner        = NULL;
    _WaitSet      = NULL; // 处于wait状态的线程，会被加入到_WaitSet
    _WaitSetLock  = 0 ;
    _Responsible  = NULL ;
    _succ         = NULL ;
    _cxq          = NULL ;
    FreeNext      = NULL ;
    _EntryList    = NULL ; // 处于等待锁block状态的线程，会被加入到该列表
    _SpinFreq     = 0 ;
    _SpinClock    = 0 ;
    OwnerIsThread = 0 ;
  }
```

ObjectMonitor中有两个队列，**_WaitSet 和 _EntryList**，用来保存ObjectWaiter对象列表（ **每个等待锁的线程都会被封装成ObjectWaiter对象** ），**_owner指向持有ObjectMonitor对象的线程**，当多个线程同时访问一段同步代码时：

```
1. 首先会进入 _EntryList 集合，当线程获取到对象的monitor后，进入 _Owner区域并把monitor中的owner变量设置为当前线程，同时monitor中的计数器count加1；
2. 若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSet集合中等待被唤醒；
3. 若当前线程执行完毕，也将释放monitor（锁）并复位count的值，以便其他线程进入获取monitor(锁)；
```

同时，Monitor对象存在于每个java对象的对象头MarkWord中（存储的指针指向），synchronize锁便是通过这种方式获取锁的，也是为什么任意对象可以作为所得原因，同时notify/notifyAll/wait等方法都会用到Monitor锁对象，所以必须在同步代码块中使用。

​	监视器Monitor有两种同步方式：互斥与协作。在多线程环境下线程直接如果需要共享数据，就需要解决互斥访问数据的问题，**监视器可以确保监视器上的数据在同一时刻只会有一个线程在访问。**

**什么时候需要协作**？比如：

```
	一个线程向缓冲区写数据，另一个线程从缓冲去读取数据，如果读线程发现缓冲区为空就会等待，当写线程向缓冲区写入数据就会唤醒读线程，这里读线程和写线程就是一个合作关系。JVM通过Object类的wait方法来使自己等待，在调用wait方法后，该线程会释放它持有的监视器，直到其他线程通知它才有执行的机会。一个线程调用notify方法通知在等待的线程，这个等待的线程并不会马上执行，而是要通知线程释放监视器后，它重新获取监视器才有执行的机会，如果刚好唤醒的这个线程需要的监视器被其他线程抢占，那么这个线程就会继续等待。Object类中的notifyAll方法可以解决这个问题，它可以唤醒所有等待的线程，总有一个线程执行。
```

![img](https://user-gold-cdn.xitu.io/2018/7/27/164daccb3b88464e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

如上图所示，一个线程通过1号们进入Entry Set（入口区），如果在入口区没有线程等待，那么这个线程就会获取监视器成为监视器的Owner，然后执行监视器区域的代码。如果在入口区中有其他线程等待，那么新来的线程也会和这些线程一起等待。线程在持有监视器的过程中，有两个选择，**一个是正常执行监视器区域的代码**，释放监视器，通过五号门退出监视器；**还有可能等待某个条件的出现**，于是他会通过3号门到Wait Set（等待区）休息，直到相应的条件满足后在通过4号门进入重新获取监视器再执行。

注意：

```
当一个线程释放监视器时，在入口区和等待区的等待线程都回去竞争监视器，如果入口区的线程赢了，会从2号门进入；如果等待区的线程赢了就会从4号门进入，只有通过3号门才能进入等待区，在等待区中的线程只有通过4号门才能退出等待区，也就是说一个线程只有在它持有监视器时才能执行wait操作，处于等待的线程只有在次获得监视器才能退出等待状态。
```

#### 锁优化

​	从JDK5引入了现代操作系统新增加的CAS原子操作（JDK5中并没有对synchronize关键字做优化，而是体现在J.U.C中，所以在JDK5版本Concurrent包有更好的性能），从JDK6开始，就对synchronize的实现机制进行了较大调整，包括使用JDK5引进的CAS自旋之外，还增加了自适应的CAS自旋、锁消除、锁粗化、偏向锁、轻量级锁这些优化策略。由于次关键字的优化使得性能极大提高，同时语义清晰、操作简单、无需手动关闭，在允许的情况下尽量使用synchronize关键字，同时在性能上synchronize还有优化空间。

锁主要存在四种状态，**无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态**。锁可以从偏向锁升级到轻量级锁，在升级到重量级锁，但是锁的升级是单向的。锁只能从低到高升级，不会出现降级的情况。在JDK1.6中默认是开启偏向锁和轻量级锁的。

#### 自旋锁

​	线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大压力。同时很多应用上面，**对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁的阻塞和唤醒线程是非常不值得的**。所以在这种情况下引入了自旋锁。

```
所谓自旋锁，就是值当一个线程尝试获取某个锁时，如果该锁已被其他线程占用，就一直循环检测锁是否被释放，而不是进入线程挂起货睡眠状态。
```

**自旋锁适用于锁保护的临界区很小的情况，临界区很小，锁占用的时间就很短**。自旋等待不能替代阻塞，虽然它可以避免切换线程带来的开销，但是它占用了CPU处理器的时间。**如果持有锁的线程很快就释放了锁，那么自旋的效率非常好，反之，自旋的线程就会白白消耗处理的资源，它不会做任何有意义的工作，只是一直旋转重复循环检测锁是否被释放，这样反而会带来性能上的浪费。所以自旋等待的时间必须要有一个限度，如果自旋超过了定义的时间仍没有获取到锁，则应该被挂起。

**自旋锁在JDK 1.4.2中引入，默认关闭**，但是可以使用-XX:+UseSpinning开开启，**在JDK1.6中默认开启**。同时自旋的默认次数为10次，**可以通过参数-XX:PreBlockSpin来调整**。

如果通过参数-XX:PreBlockSpin来调整自旋锁的自旋次数，会带来诸多不便。假如将参数调整为10，但是系统很多线程都是等你刚刚退出的时候就释放了锁（假如多自旋一两次就可以获取锁），是不是很尴尬。**于是JDK1.6引入自适应的自旋锁，让虚拟机会变得越来越聪明**。

#### 适应性自旋锁

​	适应性自旋锁是在JDK1.6中引入的。所谓自适应就是值自旋的次数不固定，次数由前一次在同一个锁上的自选时间和锁的拥有者的状态来决定。

```
线程如果自旋成功获取到锁了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次自旋成功了没那么此次自旋也很有可能再次成功，那么它将会允许自旋等待持续的次数更多，相反，如果一个锁，很少有自旋能够成功，那么在后面要获取这个锁时候，自旋的次数会减少甚至省略掉自旋的过程，以免浪费处理器资源。
```

#### 锁消除

为了保证数据的完整性，在进行操作是需要对这部分操作进行同步控制，**但是在有些情况下，JVM检测到不可能存在共享数据竞争，这时JVM会对这些同步锁进行锁消除**。（**锁消除的依据是逃逸分析的数据支持**）

​	如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间，变量是否逃逸，对虚拟机来说需要使用数据流分析来确定，但是对于开发者来说很清楚，在不存在数据竞争的代码块不会去强行加上同步。但是有时候程序并不是我们所想的那样，虽然没有显示使用锁，但是在一些JDK的内置API中会有隐形的加锁操作。例如StringBuffer的append()方法，Vector的add()方法。

```
public void vectorTest(){
    Vector<String> vector = new Vector<String>();
    for(int i = 0 ; i < 10 ; i++){
        vector.add(i + "");
    }
	System.out.println(vector);
}
```

#### 锁粗化

在使用同步锁的时候，需要让同步块的作用范围尽可能小，仅在共享数据的实际作用域中才进行同步，这样是**为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁**。

**但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗化的概念。**（**将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁**） 

例如上面的实例：

​	vector每次add的时候都需要加锁操作，JVM检测到对同一个对象连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到for循环之外。

#### 偏向锁

​	偏向锁是JDK6中重要的引进，**在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得**，为了让线程获得锁的代价更低，引进了偏向锁。

**偏向锁是在单线程执行代码快时使用的机制**，**如果在多线程并发的环境下**，（即线程A尚未执行完同步代码块，线程B发起了申请锁的申请）**则一定会转化为轻量级锁或重量级锁**。

引入偏向锁主要目的是：**为了在没有多线程竞争的情况下尽量减少不必要的轻量级锁执行路径**。原因是：轻量级锁的加锁 解锁操作是需要依赖多次CAS原子指令的，**而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令**。即使线程执行时出现多线程竞争的情况将偏向锁撤销操作的性能消耗也必须小于节省下来的CAS原子指令的性能消耗。

```
轻量级锁是为了在现场交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进步一提供性能。
```

偏向锁是如何来减少不必要的CAS操作呢：

```
现在几乎所有的锁都是可以重入的，即已获得锁的现场可以多次锁住/解锁监视器对象，而每次加锁/解锁都会涉及到一些CAS操作（比如等待队列的CAS操作），CAS操作会延迟本地调用，因此偏向锁的想法是一旦现场第一次获得了监视器对象，之后让监视器对象“偏向”这个线程，之后的多次调用则可以避免CAS操作，说白了就是置个变量，如果发现为true则无需在走各种加锁/解锁流程。
```

CAS为什么会引入本地延迟？

![SMP(对称多处理器)架构](https://user-gold-cdn.xitu.io/2018/7/30/164e96df76e9c39a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

​	首先**CAS是一条CPU的原子指令**，作用是让cpu比较后**原子地更新某个位置的值**，他的实现方式是基于硬件平台的汇编指令，就是说CAS是靠硬件实现的，JVM只是封装了汇编调用。

​	其次CPU会共享一条系统总线（BUS），**靠此总线链接主存**，每个核还有自己的一级缓存，**其中任意一个核都有可能把主存某个位置的值load到自己cache中**，当其中一个cache修改了这个位置的值时需要通过总线使其它核的cache对应值“失效”，根据cache一致性（**MESI协议**）协议，**其他核cache发现自己值失效（cache命中缺失）则会通过总线去主存重新load该地址的最新值**，这样就会需要一个通过总线的来回通信称为“**cache一致性流量**”，因为总线被设计为固定的“通信能力”，如果cache一致性流量过大，总线将成为瓶颈。这个层面上来说，**锁设计的终极目标就是减少cache一致性流量**。

​	这样CAS恰好会导致cache一致性流量，**如果有很多线程都共享同一个对象，当某个核CAS成功时必然会引起总线风暴，这就是所谓的本地延迟**，本质上偏向锁就是为了消除CAS，降低Cache一致性流量。

所以，当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储偏向的线程ID，以后该线程进入和退出同步块时不需要话费CAS操作来争夺锁资源，只**需要检查是否为偏向锁，锁标识为和ThreadID就行了**。流程为：

```
1.检测Mark Word是否为可偏向状态，即：是否为偏向锁1，锁标识位为01；
2.如果为可偏向状态，则检查线程ID是否为当前线程ID，如果是执行步骤5，不是则执行步骤3；
3.如果线程ID不是当前线程ID，通过CAS操作竞争锁，竞争成功就将Mark Word的线程ID替换成当前线程ID，否则执行步骤4；
4.CAS竞争锁失败，证明当前存在多线程竞争情况，当线程执行到达安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；
5.执行同步代码块；
```

偏向锁的释放采用的是一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待线程到达全局安全点，步骤为：

```
1.暂停拥有偏向锁的线程；
2.判断锁对象是否还处于被锁定状态，如果不是则恢复到无锁状态（01），让其他的线程竞争锁。如果是锁定状态，则挂起持有锁的当前线程，并将指向当前线程的锁记录地址的指针放入对象头Mark Word，升级为轻量级状态（00），然后恢复持有锁的当前线程，进入轻量级锁的竞争模式；

注意：这里将当前线程挂起在恢复的过程中并没有发生锁的转移，锁依然在当前线程手中，只是穿插了“将对象头的线程ID变更为指向锁记录地址的指针”。
```

![偏向锁的获取和释放过程](https://user-gold-cdn.xitu.io/2018/7/27/164daccb43f3dfe6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### 轻量级锁

引入轻量级锁的主要目的是**在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗**。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试尝试获取轻量级锁，步骤如下：

1.在线程进入同步块时，如果同步对象锁状态为无锁状态（锁标志位为“01”，是否为偏向锁为“0”），虚拟机 会先在当前线程的栈帧中建立一个叫锁记录（lock Record）的空间，用来存储锁对象当前的Mark Word的拷贝，如下图所示：

![轻量级锁CAS操作之前线程堆栈与对象的状态](https://user-gold-cdn.xitu.io/2018/7/27/164daccb3b8673a5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

2.将拷贝对象头中的Mark Word复制到Lock Record中；

3.拷贝成功后，虚拟机将使用CAS操作尝试将对象Mark Word 中的Lock Word更新为指向当前线程Lock Record的指针，并将Lock Record里的Owner指针指向ObjectMarkWord。如果更新成功则执行步骤4，不成功则执行5.

4.如果这个更新动作成功了，那么当前线程就拥有了该对象的锁，并且对象MarkWord的锁标志位设置为“00”，表示对象处于轻量级锁定状态，此时线程堆栈与对象头的状态如下图：

![轻量级锁CAS操作之后线程堆栈与对象的状态](https://user-gold-cdn.xitu.io/2018/7/27/164daccb3fc92904?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

5.**如果更是操作失败了，虚拟机首先会检查对象MarkWord中的Lock Word是否指向当前线程的栈帧**，如果是，**就说明当前线程已经拥有了这个对象的锁**，那就可以直接进入同步代码块执行。**否则说明多个线程竞争锁，进入自旋执行步骤3，若自旋结束仍未获得锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，MarkWord中存储的就是指向重量级锁（互斥量）的指针，当前线程及后面等待锁的线程都要进入阻塞状态。**

轻量级锁的释放也是通过CAS操作进行的：

```
1.通过CAS操作尝试把线程中复制到LockRecord中的MarkWord对象替换当前的MarkWord；
2.如果替换成功，整个同步过程就完成了，恢复到无锁状态“01”；
3.如果替换失败，说明有其他线程尝试过获取该锁（此时锁已经膨胀），就要在释放锁的同时，唤醒被挂起的线程；
```

轻量级说性能提升的依据是**对于绝大部分的锁，在生个生命周期内都都不会存在竞争**。如果打破这个依据则除了互斥的开销外，还有额外的CAS操作，**因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢**。

![轻量级锁的获取和释放过程](https://user-gold-cdn.xitu.io/2018/7/27/164daccb44e0f4af?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

为什么升级为轻量级锁时要把对象头里的Mark Word复制到线程的锁记录中呢？

```
因为在申请对象锁时需要以改值作为CAS的比较条件，同时在升级到重量锁的时候，能通过这个比较判定是否在持有锁的过程中此锁被其他线程申请过，如果其他现场申请了，则在释放锁的时候要唤醒被挂起的线程。
```

为什么会尝试CAS不成功以及什么情况下会不成功？

```
	CAS本身是不带锁机制的，其实是通过比较而来。假设两个线程都在对象头里的锁标识为无锁状态进入，其中一个线程A先更新对象头为其锁记录指针成功之后，另一个线程B在用CAS去更新，就会发现此时的对象头已经不是其操作前的对象HashCode了，所以CAS会失败，也就是说只有两个现场并发申请锁的时候会发生CAS失败。
	然后线程B进行CAS自旋，等待对象头的锁标识重新变回无锁状态或对象头内容等于对象HashCode（因为这是现场B做的CAS操作前的值），这也就意味着线程A执行结束（只有线程A执行完毕撤销锁了才会重置对象头），此时线程B的CAS操作终于成功了，于是线程B获得了锁以及执行同步代码的全限。如果线程A执行的时间较长，线程B经过若干次CAS时终没有成功，则锁膨胀为重量级锁，即线程B被挂起阻塞、等待重新调度。
```

轻量级锁：**“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。**但是**轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。**

```
轻量级锁适应的场景是线程交替执行同步快的情况，如果存在同一时间访问同一锁的情况，必然就会导致轻量级锁膨胀为重量级锁。
```

#### 重量级锁

Synchronize是通过对象内部的一个叫做**监视器锁（Monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的MutexLock来实现的，而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比长的时间**。这就是为什么Synchronize效率低的原因。因此，这种依赖于操作系统Mutex Lock所实现的锁称之为“重量级锁”。

##### 重量级锁、轻量级锁和偏向锁之间的转换

![重量级锁、轻量级锁和偏向锁之间转换](https://user-gold-cdn.xitu.io/2018/7/27/164daccb60a8ec5e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### 锁的劣势

​	各种锁并不是相互代替的，**而是在不同场景下的不同选择**，绝对不是说重量级锁是不合适的。**锁只能升级，不能降级**，这个过程就是开销逐渐加大的过程。

```
1.如果是单线程使用，偏向锁毫无疑问是代价最小，并且它就能解决问题，连CAS都不用做，仅仅在内存中比较小对象头就行了。
2.如果出现了其他线程竞争，则偏向锁就会升级为轻量级锁；
3.如果其他线程通过一定次数的CAS尝试没有成功，则进入重量级锁；
```

在第三种情况下进入同步代码块就**要做偏向锁建立、偏向锁撤销、轻量级锁建立、升级到重量级锁，最终还是的靠重量级锁来解决问题，那这样的代价就比直接用重量级锁要大不少了**。所以使用那种技术，一定要看其所处的环境及场景，**绝大多数情况下，偏向锁是有效的，基于hotSpot发现的“大多数锁只会由同一线程并发申请”的经验规律**。

![锁的优劣](https://user-gold-cdn.xitu.io/2018/7/27/164daccb8b4a0ebd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## JUC

​	

​	JUC是java.util.concurrent开发包的简称，是在java 5.0中添加的；传统线程编程模型之中为防止死锁等现象的出现（wait()、notify()、synchronized）时往往会考虑性能、公平性、资源管理等问题，加重了程序开发人员的负担；而利用JUC进行多线程的编程可以有效的减少竞争条件和死锁线程。

### 基础使用

​	Atomic原子类，根据数据类型一共分为4类。

#### 1.基本类型

​	AtomicInteger（整形原子类）

​	AromaticLong（长整形原子类）

​	AtomicBoolean（布尔型原子类）

这个三个类型的方法基本相同，所以以AtomicInteger为例来介绍，

##### 定义

```java
public class AtomicInteger extends Number implements jvav.io.Serializable{
    private static final long seriavlVersionUID=6214790243416807050L;
    
    //引入unsafe对象，电泳compareAndSwapInt方法进行cas更新操作
    private static final Unsafe unsafe=Unsafe.getUnsafe();
    private static final long valueOffset;
    
    static {
        try{
            valueOffset =unsafe.objectFieldOffset(
                AtomicInteger.class.getDeclaredField("value"))
        }catch(Exception ex){throw new Error(ex);}
    }
    private volatile int value;
}
```

AtomicInteger类主要利用CAS+volatile和native方法来保证原子操作，从而避免Synchronize的高开销，执行效率大为提升。

CAS的原理是拿期望的值和原本的一个值做比较，如果相同则更新成新的值，Unsafe类的objectFieldOffset()方法是一个本地方法，这个方法是用来获取“原来的值”的内存地址，返回值是valueOffset。另外value是一个volatile变量，在内存中可见，因此jvm可以保证任何时刻线程总能拿到该变量的最新值。

##### 常用方法

```java
//获取当前值
public final int get();
//获取当前的值，并设置新的值
public final int getAndSet（int newValue）；
//获取当前的值，并自增
public final int getAndIncrement();
//获取当前值，并自减
public final int getAndDecrement();
//获取当前值，并加上预期值
public final int getAndAdd(int delta);
//如果输入的数值等于预期值，则以原子方式将该值设置为输入值(update)
boolean compareAndSet(int expect, int update)
//最终设置为newValue，使用lazySet设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值
public final void lazySet(int new Value)
```

#### 2.数组类型

使用原子的方式更新数组里的某个元素

​	AtomicIntegerArry（整型数组原子类）

​	AtomicLongArray（常整型数组原子类）

​	AtomicReferenceArray（引用类型数组原子类）

```java
//获取 index=i 位置元素的值
public final int get(int i)
//返回 index=i 位置的当前的值，并将其设置为新值：newValue
public final int getAndSet(int i, int newValue)
//获取 index=i 位置元素的值，并让该位置的元素自增
public final int getAndIncrement(int i)
//获取 index=i 位置元素的值，并让该位置的元素自减
public final int getAndDecrement(int i)
//获取 index=i 位置元素的值，并加上预期的值
public final int getAndAdd(int delta)
//如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值（update）
boolean compareAndSet(int expect, int update)
//最终 将index=i 位置的元素设置为newValue,使用 lazySet 
//设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。
public final void lazySet(int i, int newValue)
```

#### 3.引用类型

基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用 引用类型原子类。

​	AtomicReference(引用类型原子类)

​	AtomicStampedRerence(原子更新引用类型里的字段原子类)

​	AtomicMarkableReference(原子更新带有标记位的引用类型)

#### 4.对象的属性修改类型

如果需要原子更新某个类里的某个字段时，需要用到对象的属性修改类型原子类。

​	AtomicIntegerFieldUpdater（原子更新整形字段的更新器）

​	AtomicLongFieldUpdater(原子更新长整形字段的更新器)

​	AtomicStampedReference (原子更新带有版本号的引用类型)该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。

### locks

#### Condition接口

Condition可以通俗的理解为条件队列。当一个线程在调用了await方法以后，直到线程等待的某个条件为真的时候才会被唤醒。这种方式为线程提供了更加简单的等待/通知模式。Condition必须要配合锁一起使用，因为对共享状态变量的访问发生在多线程环境下。一个Condition的实例必须与一个Lock绑定，因此Condition一般都是作为Lock的内部实现。

```java
public interface Condition{
    //调用此方法释放锁，线程进入等待状态，如果在等待状态中被中断会抛出被中断异常
    void await()throws InterruotedException;
    //与await区别是，如果线程中断，不会抛出异常，仅仅再次设置为中断状态
    void awaitUninterruptibly();
    //当前线程进入等待状态直到被通知，中断或超时
    long awaitNanos(long nanosTimeout) throws InterruptedException;
    boolean await(long time,TimeUnit unit)throws InterruptedException;
    //当前线程进入等待状态直到被通知，中断或者到了某个时间
    boolean awaitUntil(Date deadline) throws InterruptedException;
    //唤醒一个等待中condition上的线程，将该线程从等待堆中转移到同步队列中
    void signal();
    //唤醒所有等待在condition上的线程
    void signalAll();
}
```

#### AQS抽象类

​	AbstractQueuedSynchronize简称AQS，是一个用于构建同步锁和同步容器的框架，事实上Concurrent包内许多累都是基于AQS构建，例如ReentrantLock（重入锁）,Senaphore（技术信号量），CountDownLatch（原子计数器）,ReentrantReadWriteLock（读写锁）,FutureTask（创建多线程任务）等。AQS解决了在实现同步容器时设计的大量细节问题。

​	AQS中还有一个表示状态的字段state，例如ReentrantLock用它表示线程重入次数，Semaphore用它表示剩余许可数量，FutureTask用它表示任务的状态面对state变量值的更新都采用CAS操作保证更新操作的原子性。AbstractQueuedSynchronize继承了AbstractOwnableSynchronize，这个类只有一个变量：exclusiveOwnerThread，表示当前占用该锁的线程，并且提供了相应的get，set方法。

优质文章 <https://juejin.im/post/5a4a4530518825697078553e>

**源码分析**

```java
public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer
    implements java.io.Serializable {
    
    static final class Node {
        /** 共享节点 */
        static final Node SHARED = new Node();
        /** 标记表示节点正在独占模式下等待 */
        static final Node EXCLUSIVE = null;
        /** waitStatus= 1表示线程已取消 */
        static final int CANCELLED =  1;
        /** waitStatus= -1表示后继者的线程需要取消停放（需要被唤醒） */
        static final int SIGNAL    = -1;
        /** waitStatus= -2 表示线程正在等待条件，进入了condition队列中 */
        static final int CONDITION = -2;
        /** waitStatus= -3 值表示下一个acquireShared应该无条件传播 */
        static final int PROPAGATE = -3;

       
        volatile int waitStatus;
		/** 前节点 */
        volatile Node prev;
		/** 后节点 */
        volatile Node next;
		/** 节点对应线程 */
        volatile Thread thread;
		/** 等待队列中的后继节点 */
        Node nextWaiter;
       
    }
	/** 同步队列头结点 */
    private transient volatile Node head;
	/** 同步队列尾结点 */
    private transient volatile Node tail;
	/** 同步状态 
    * 
    *
    */
    private volatile int state;
    
    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
            	// 获取node的前驱节点
                final Node p = node.predecessor();
                // 如果node前驱节点为head 头节点，并且再次尝试cas 更新去获取锁
                if (p == head && tryAcquire(arg)) {
                	//如果获取成功，这将node设置为同步队列新的头结点
                    setHead(node);
                    // 原来头结点next置为空
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                // 如果 p 不是同步队列头部节点，或者node 再次尝试获取锁失败，
                // 则通过cas 将当前node前一个节点 waitStatus = SINGAL = -1
                // 并且将当前node 线程设置阻塞
                if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())
                    interrupted = true;
                //如果以上两个条件都不成立，那么for循环会一直循环下去
           }
            	
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
    
    
    /**
    * ConditionObject构造了一个条件等待队列，实现了Condition接口，
    *
    *
    */
    public class  ConditionObject implements Condition, java.io.Serializable {
        private static final long serialVersionUID = 1173984872572414699L;
        /** 条件等待队列 头节点 */
        private transient Node firstWaiter;
        /** 条件等待队列 尾节点 */
        private transient Node lastWaiter;
        
        public final void signal() {
        	//如果不是独占锁模式，则抛出 非法监视器异常
            if (!isHeldExclusively())
                throw new IllegalMonitorStateException();
            //获取条件等待队列的头部节点
            Node first = firstWaiter;
            if (first != null)
            	//将获取到的头部节点加入到同步队列中
                doSignal(first);
        }
        private void doSignal(Node first) {
            do {
                //将firstWaiter指向下一个节点如果下一个节点为空，则将lastWaiter置为空
                if ((firstWaiter = first.nextWaiter) == null)
                    lastWaiter = null;
                //断开头结点与其他节点的连接
                first.nextWaiter = null;
            } while (!transferForSignal(first) && (first = firstWaiter) != null);
		}
 
 		final boolean transferForSignal(Node node) {
            /*
             * 所谓的condition队列和sync队列就在于waitStatus的值
             * 在这里将waitStatus改为NORMAL，如果不能改变，说明当前节点已经被取消（CANCELLED），
             * 那么重新尝试下一个节点
             */
            if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
                return false;

            /*
             * 将当前节点移动到sync队列中，接着设置前驱节点等待状态，
             * 如果被取消或者设置状态失败，那么唤醒该线程，让该线程重新同步，为了确保waitStatus是无害的
             */
            Node p = enq(node);/*当前节点的前驱节点*/
            int ws = p.waitStatus;
            /*如果前驱节点取消，或修改状态失败*/
            if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
                /*唤醒当前线程*/
                LockSupport.unpark(node.thread);
            return true;
		}

         public final void await() throws InterruptedException {
         	//如果当前线程已经被中断
            if (Thread.interrupted())
                throw new InterruptedException();
            //将调用await方法的线程添加到Condition 条件队列尾部
            Node node = addConditionWaiter();
            //释放当前线程持有的锁 1
            int savedState = fullyRelease(node);
            int interruptMode = 0;
            //一直循环检查当前线程是否已经在AQS的同步队列中了
            while (!isOnSyncQueue(node)) {
            	//不在同步队列中，则将此线程挂起
                LockSupport.park(this);
                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                    break;
            }
            // 如果已经在同步队列中了，则尝试重新获取1处释放的锁
            if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
                interruptMode = REINTERRUPT;
            if (node.nextWaiter != null) // clean up if cancelled
                unlinkCancelledWaiters();
            if (interruptMode != 0)
                reportInterruptAfterWait(interruptMode);
        }
        
     }
	//省略部分代码。。。。
}
 
```



#### Lock 接口

```java
public interface Lock{
    //方法是平常使用的最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。
    void lock();
    
    /**
    * 如果线程正在等待获取锁，则这个方法能够响应中断，即中断线程的等待状态。也就是说
    * 当两个线程同事通过lock。lockinterruptibly()想获取某个锁时，假若此时线程A获取到锁
    * 而线程B只有在等待，那么对线程B调用threadB。interrupt()放过能够中断线程B的等待过程
    * 由于lockInterruptibly()的声明中抛出了异常，所以     				 	       *lock.lockinterruptedException()必须放在try块中或者在调用lockInterruptibly()	* 的方法声明抛出InterruptedException。
    */
    void lockInterruptibly() throws InterrptedException;
    
    /**
    *	如果方法是返回值的，它表示用来尝试获取锁，如果成功则返回true，
    *	如果获取失败，则返回false，也就是说这个方法无论如何都会立即返回
    *	拿不到锁时不会一直在那等待，方法直接返回
    */
    boolean tryLock();
    
    /**
    *	当方法拿不到锁时会等待一段时间，如果在期间限之内还拿不到锁就返回false
    *	如果在时间期限内拿到锁，则返回true，一般情况用tryLock来获取锁时是这样使用
    */
    boolean tryLock(long time,TimeUnit unit)throws InterruptedException
    
    //释放锁
    void unlock();
    
    condition newCondition();
}
```

#### ReentrantLock的实现

ReentrantLock是Lock众多实现之一，像其他实现还有ReadLock，WriteLock...等，这里只介绍ReentrantLock，因为他们的实现都是大同小异，都是依赖java.util.Concurrent。

ReentrantLock的调用流程：

![img](https://images2015.cnblogs.com/blog/893686/201609/893686-20160906010114176-2045098870.jpg)

ReentrantLock实现了lock接口，内部抽象类sync继承了AbstractQueuedSynchronizer，NonfairSync和FairSync都继承了sync，分别实现了非公平锁和公平锁，

公平锁：严格按照线程启动的顺序来执行，不允许其他线程插队执行。

非公平锁：允许线程插队执行。

默认情况下ReentrantLock是通过非公平锁来进行同步的。

##### 非公平锁

这是最简单的获取ReentrantLock非公平锁代码。

```java
ReentrantLock lock = new ReentrantLock();
lock.lock();
```

源码分析：

```java
final void lock(){
    //首先尝试看能不能获取到锁，如果CAS成功，那么就获取到了
    if(compareAndSetState(0,1))
        //如果获取到了就记录下当前线程，以便后面的重入
    	setExclusiveOwnerThread(Thread.currentThread());
    else
        //如果CAS失败，则调用acquire方法
    	acquire(1);
}
```

```java
public final void acquire(int arg){
    if(!tryAcquire(arg) && acquieeQueued(addWaiter(Node.EXCLUSIVE),arg))
    	selfInterrupt();
}
```

进入acquire方法后会再尝试获取锁，如果获取到了，就返回true，就会退出if语句，如果没有获取到，那么就会将当前线程添加到队列中，并循环获取锁，直到获取到为止。

tryAcquire方法源码：

```java
final boolean nonfairTryAcquire(int acquires){
    final Thread current=Thread.currentThread();
    //获取到锁的标志状态
    int c= getState();
    if(c ==0 ){
        //0表示没有被获取到，则尝试获取
        if(compareAndSetState(0,acquires)){
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current== getExclusiveOwnerThread()){
        //这里代表锁虽然被占用了，但是就是当前线程占用的，可以重入
        int nextc =c + acquires;
        if (nextc < 0) //溢出
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return  true;
    }
    return false;
}
```

如果尝试获取锁失败了，则会先将当前线程添加到一个队列中：

```java
private Node addWaiter(Node mode){
    //使用当前线程创建一个Node节点，mode分为共享和排他
    Node node = new Node(Thread.currentThread(),mode);
    Node pred = tail;
    if(pred != null){
        //如果队列中已经存在节点了，那么直接将该节点添加到后面
        node.prev = pred;
        if(compareAndSetTail(pred,node)){
            pred.next = node;
            return node;
        }
    }
    //如果是第一次构建队列，则调用方法
    enq(node);
    return node;
}
```

```java
private Node enq(final Node node){
    for(;;){
        Node t =tail;
        if(t == null){
            //如果尾阶段还是空的，那么构建一个空节点作为头节点
            //然后下一次循环的时候进入到else
            if(compareAndSetHead(new Node()))
            tail=head;
        }else{
            //和上面一样，将当前线程构建的节点添加到队列尾部
            node.prev = t;
            if(compareAndSetTail(t,node)){
                t.next = node;
                return t;
            }
       }
    }
}
```

到这里，队列已经构建完成了，那么这个队列中的节点在有锁释放后，又是怎么去争夺锁资源的呢？

```java
final boolean acquireQueued(final Node node, int arg){
    //标示获取锁的过程中是否出现了异常
    boolean failed =true;
    try{
        //标示线程在等待唤醒的时候是否被打断
        boolean interrupted = false;
        //循环获取锁，直到获取到或者出现异常
        for(;;){
            final Node p = node.predecessor();
            //如果当前线程为第一个节点（不包含head节点），则尝试获取锁
            if(p == head && tryAcquire(arg)){
                //如果获取到了，就把当前节点设置为head
                setHead(node);
                p.next = null ;
                failed = false;
                return interrupted;
            }
            //判断节点是否需要park，如果需要则进入park
            if(shouldParkAfterFailedAcquire(p,node)&& 		     
               parkAndCheckInterrupt())
                interrupted = true;
        }
    }finally {
        if(failed)
            cancelAcquire(node);
    }
}
```

首先判断当前线程的一个节点是否为head节点，如果是的话，才会尝试获取锁。**但是非公平锁不是应该所以节点都去竞争锁资源吗？**其实**非公平是作用于新入的节点，而已经调用过addWaiter方法的节点，还是需要排队的**。

ReentrantLock判断线程获取锁失败后是否需要进入到park状态:

```java
private static boolean shouldParkAfterFailedAcquire(Node pred,Node node){
    int ws=pred.waitStatus;
    if(ws == Node.SIGNAL)
    	//如果前节点是SIGNAL状态，代表需要park
    	return true;
    if（ws > 0）{
        //如果waitStatus的值大于0，代表已取消，需要将无效的节点删除
        do{
            node.prev = pred.prev;
        }while(pred.waitStatus > 0);
        pred.next = node;
    }else{
        //否则将前节点设置为SIGNAL状态
        compareAndSetWaitStatus(pred, ws Node.SIGNAL);
    }
    return false;
}
```

以上代码主要需要知道Node的waitStatus的几种状态含义：

**CANCELLD**：值为1，在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该Node的结点，节点的waitStatus为CANCELLED，即为结束状态，进入该状态后的节点将不会再变化。

**SIGNAL**：值为-1，被标识为该等待线程唤醒状态的后续节点，当其前继节点的现场释放了同步锁或被取消，将会通知该后继节点的线程执行。

**CONDITION**：值为-2，与condition相关，该标识的节点处于等待队列中，节点的线程等待中condition上，当其他线程调用了condition的signal()方法后，CONDITION状态的节点将从等待队列转移到同步队列中，等待获取同步锁。

**PROPAGATE**：值为-3，与共享模式相关，在共享模式中，该状态标识节点的线程处于可运行状态。

**0状态**：值为0，表示初始化状态。

parkAndCheckInterrupt方法：

```java
private final boolean parkAndCheckInterrupt{
    //通过LockSupport类来park该线程
    LockSupport.Park(this);
    //将park的线程唤醒 可能是调用unpark方法也可能是被打断了
    return Thread.interrupted();
}
```

到这里，非公平锁的整个获取流程就结束了。

原理小结：

![ReentrantLock流程图](https://img-blog.csdnimg.cn/20190522193311669.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hemhlbjE5OTE=,size_16,color_FFFFFF,t_70)

注意：在最后的时候，如果线程获取到锁了。并且中途被打断过，这个时候线程会调用interrupt（），但是这个是没有任何意义的，因为运行中的线程是不能被打断的。

##### 公平锁源码解析

和非公平锁的实现原理相比，其实公平锁和非公平锁的源码差不多，只有两处不一样。

第一处：

```
final void lock(){
    acquire(1);
}
```

这里就是调用lock方法的入口，和非公平锁不一样的是非公平锁会先去尝试通过CAS获取锁，但是公平锁不会。

第二处：

```java
protected final boolean tryAcquire(int acquires){
    final Thread current =Thread.currentThread();
    int c=getState();
    if（c == 0）{
        //当state为0时，即是无锁状态时，先会去判断当前线程是否构建了节点
        //并且节点是否为head后的第一个节点，如果是，才会尝试CAS获取锁
        //其意就是每次lock后都会按head后第一个节点进行CAS获取锁，从而实现公平锁
        if(!hasQUeuedPredecessors() && compareAndSetstate(0,acquires)){
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if(current == getExclusiveOwnerThread()){
      int nextc = c+ acquires;
      if(nextc<0){
          throw new Error("Maximum lock count exceeded");
          setState(nextc);
          return true;
      }
    }
    return false;
}
```

```java
public final boolean hasQueuedPredecessors(){
    Node t=tail;
    Node h= head;
    Node s;
    //只有当没有任何节点获取锁或者本节点为head后第一个节点
    return h!=t && 
    ((s=h.next) == null || s.thread != Thread.currentThread());
}
```

总结：**公平锁的新入现场不能直接获取锁，必须去排队（除非没有任何竞争发生）。而非公平锁新入线程可以尝试获取锁，如果获取失败了在排队。**

#### LockSupport的实现

```java
//暂停当前线程
public static void park(Object blocker);
//暂停当前线程，不过有超时时间限制
public static void parkNanos(Object blocker,long nanos);
//暂停当前线程，直到某个时间
public static void parkUntil(Object blocker,long deadilne);
//无限期暂停当前线程
public static void park();
//暂停当前线程，并有超时时间限制
public static void parkNanos(long nanos);
//暂停当前线程，直到某个时间
public static void parkUntil(Thread thread);
//恢复当前线程
public static void unpark(Thread thread);
public static Object getBlocker(Threat t);
```

1.LockSupport是一个线程阻塞工具类，**所有的方法都是静态方法，**可以让线程在任意位置阻塞和释放，通常不会直接被使用，更多作为锁实现的基础工具类。

2.LockSupprt底层依赖Unsafe实现，即park()和unpark()原语方法（**原子语言,不可分割,不可中断**），通过“许可”代替状态，park方法用于线程等待“许可”，unpark方法用于为线程提供“许可”。

3.由于“许可”的存在，当出现一个线程调用park方法，其他线程调用unpark方法时，会保持活跃。

4.LockSupport和每个使用它的线程都与一个permit关联，某种意义上可认为是Semaphore类，但是区别于Semaphores，permit至多只有一个，不能被累加（重复调动unpark也不会累加，最多为1）permit相当于一个开关，（只有0和1两个值），默认为0，执行过程如下：

​	4.1 调用unpark方法，permit+1，即permit=1

​	4.2 调用park方法，permit被消费-1，即permit=0，同时park方法立即返回

​	4.3 在此调用park方法，线程会被阻塞（此时permit=0，线程无许可可用，直到permit=1之前都会被阻塞）

5.LockSupport不可重入，当一个线程多次调用park方法，线程将会被第二个park方法阻塞

6.LockSupport支持中断响应，线程调用park阻塞时仍能够响应中断请求，但不会抛出InterruptedException异常。

7.suspend() 、wait()、park()的区别：

​	suspend：不会释放锁。

​	wait：会释放锁还支持超时处理

​	park：

​		1.LockSupport解决了suspend不释放锁从而容易死锁的问题，例如resume方法被阻塞时，其他线程在调用resume方法之前获取同步锁时被阻塞而导致resume方法无法执行进而导致死锁。

​		2.LockSupport不需要先获得某个对象的锁，也不会排除InterruptedException异常，unpark方法可以先于park方法调用，其没有方法调用的时序问题。（wait\notify机制有个问题在于线程调用notify方法去唤醒其他线程时，需要保证需要被唤醒的线程必须被wait方法阻塞，否则被唤醒线程永远会出于Waiting状态，同事notify只能唤醒一个线程，当同时又多个线	程在同一对象上wait等待，就只能有一个线程可以被唤醒，并且不能指定唤醒某个线程）

​	park/unpark机制通过引入的那个“许可”的概念实现对线程同步的解耦，线程间无须关心对方状态，因为不需要一个变量专门用于储存状态

8.LockSupport和Object

这里主要是对比LockSupport.park/unpark()与object.wait/notify()的区别

​	**面向对象不同**：LockSupport能够主动指定Thrad；Object必须被动执行且不能准确指定，有随机性。

​	**监视器是否必须**：LockSupport只需要“许可”，因此无需监视器；object使用的前提是必须获取监视器，即wait/notify必须出现在synchronize作用范围内

​	**实现机制不同**：LockSupport使用的是“许可”，object使用的是监视器，两个没有交集，互相不会影响

<https://www.zybuluo.com/kiraSally/note/866972>

#### ReentrantReadWriteLock的实现

ReadWriteLock接口只定义了两个方法：

```java
public interface ReadWriteLock{
    lock readLock();
    Lock writeLock();
}
```

通过调用相应方法获取读锁或写锁，获取的读锁及写锁都是lock接口的实现，可以如同使用lock接口一样使用。

用例：

```java
 private final Map<String, Data> m = new TreeMap<String, Data>();
    private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
    private final Lock r = rwl.readLock();
    private final Lock w = rwl.writeLock();
 
    public Data get(String key) {
      r.lock();
      try { return m.get(key); }
      finally { r.unlock(); }
    }
    public String[] allKeys() {
      r.lock();
      try { return m.keySet().toArray(); }
      finally { r.unlock(); }
    }
    public Data put(String key, Data value) {
      w.lock();
      try { return m.put(key, value); }
      finally { w.unlock(); }
    }
    public void clear() {
      w.lock();
      try { m.clear(); }
      finally { w.unlock(); }
    }
  }
```

与普通重入锁使用的主要区别在于需要使用不同的锁对象引用读写锁，并且在读写时分别调用对应的锁。

通过实例可以发现，读写锁需要关注的重点函数为获取读锁及写锁的函数，对于读锁及写锁对象则主要关注加锁和解锁函数，函数关系如下：

![img](https://segmentfault.com/img/remote/1460000015768006)

从图中可见读写锁的加锁解锁操作最终都是调用ReentrantReadWriteLock类的内部类Sync提供的方法。Sync对象通过继承AbstractQUeuedSynchronizer进行实现。

总结：ReentrantReadWriteLock读写锁，与ReentrantLock一样默认非公平，内部定义了读锁ReadLock()和写锁WriteLock()，在**同一时间允许被多个读线程访问，但在写线程访问时，所有的读线程和写线程都会被阻塞。**读写锁主要特性：公平性、可重入性、锁降级。

#### StampedLock实现

StampedLock是JDK8新增的读写锁，和其他同步锁不同，它不是由AQS实现的。而是一个基于能力（capability-based）的锁，提供了三种模式来控制read/Write的获取，并且内部实现了自己的**同步等待队列**。

1.**StampedLock的状态由一个版本和模式构成。**锁获取方法返回一个long型的值-stamp，用来表示并控制对锁状态的访问；0表示锁授权失败。锁释放和转换方法需要用stamp作为参数，如果它和锁状态不匹配操作就会失败。StampedLock提供了三种锁模式来控制读写锁的获取：

**写锁**：使用writeLock方法获取 ，当锁不可用时会阻塞，获取成功后返回一个与这个写锁对应的stamp，在unlockWrite方法中，需要通过这个stamp来释放与之对应的锁。在tryWriteLock同样也会提供这个stamp，当在write模式中获取到写锁时，读锁不能被获取，并且所有的乐观读锁验证（valitate方法）都会失败。

**读锁**：使用readLock方法获取，当超出可用资源时会阻塞，同样的，在获取锁成功后也会返回stamp，作用与上述相同。tryReadLock同样如此。

**乐观读锁**：使用tryOptimisticRead方法获取，**只有在写锁可用时才能成功获取乐观锁**，获取成功后也会返回一个stamp。validate方法可以根据这个stamp来判断写锁是否被获取。这种模式可以理解为一个弱化的读锁（weak version of a read-lock），它在任何时候都能被破坏。乐观读锁模式常被用在断的只读的代码段，用来减少争用并提供吞吐量。乐观读区域应该只读取字段，并将他们保存在本地变量中，以便在验证（validate方法）后使用。在乐观读模式中字段的读取可能会不一致，可能需要反复调用validate()来检查一致性。如：档首次读取一个对象或数组引用，然后访问其中一个的字段、元素或方法时，这些步骤通常是必须的。

**StampedLock还支持在三种模式中提供有条件转换**。例如：tryConvertTowriteLock方法尝试升级一个锁模式，下面三种情况下可以升级模式并返回一个有效的write stamp：

（1）已经在writing模式中

（2）在reading模式中并且没有其他读线程

（3）在乐观读模式中锁可用

这些方法的表现形式旨在帮助减少由基于重试（retry-based）设计造成的代码膨胀。

**StampedLock是不可重入的**。StampedLock被设计为线程安全模型的内部工具类。它的使用依赖于对数据、对象和方法的内部属性有一定的了解。StampedLock是不可重入的，所以在锁的内部不能调用其他尝试重复获取锁的方法。一个stamp如果在很长时间都没有使用或验证，在很长一段时间之后可能就会验证失败。**StampedLock是可序列化的。但是反序列化后变为初始的非锁定状态，所以在远程锁定中是不安全的**。

**StampedLock的调度策略不会始终偏向读线程或者写线程**，所有的“try”方法都是尽最大努力获取，并不一定遵循任何调度或公平策略。从“try”方法获取或转换锁失败返回0时，不会携带任何锁的状态信息。由于StampedLock支持多个锁模式的协调使用，他不会直接实现lock或readWriteLock接口，但是如果程序需要lock的相关功能。它可以通过asReadLock()、asWriteLock()和asReadWriteLock()方法返回一个lock视图。

StampedLock等待队列：

![img](https://upload-images.jianshu.io/upload_images/6050820-c3187bc3f1c4c390.png?imageMogr2/auto-orient/strip|imageView2/2/w/855/format/webp)

**无论写锁还是读锁，都不支持condition等待**

#### CounrDownLatch的实现

CountDownLatch是一个同步辅助类，通过AQS实现一个闭锁，在其他线程完成它们的操作之前，允许一个多个线程等待。简单来说，**CountDownLatch中有一个锁计数，在计数到达0之前，线程会一直等待**。

![img](data:image/gif;base64,R0lGODlhIQK1AWYAACH5BABkAAAAIf8LTkVUU0NBUEUyLjADAQAAACwAAAAA%0AIQK1Aab////3lkbf398gICC/v79AQEAAAACvrauPjYz39/fv7+9QUFDX19cY%0AGBjYgz0/ODEQEBC5cDSXlZMgGxfPz883MCrgiD9ONSF/fHlPSUPJejlYWFjB%0AdTdwcHAvIhgvKiUoKCgwMDCaXizojUJgWlUAAByqaTRlQSM4VTw3KBuwlkaw%0APADUVRD3ljLvkUR8Til7SyM3KiAYFBEQDAn3ljxjAAB8UCtHQjyem5gAPDIf%0AGBLn5+fHx8c+LB23tbMnIBqxbDJ/eneiYi6LIgCLVitja0ZwbGlYUk6qZzCD%0AUSgvJyEIBgWXl5d4dXJoZGFoaGhgYGA4AABjABBtRiZgW1f3gCeiZDJXUUyL%0AgEb3axxdPSNGMR8/MCOSWSkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH/4AAgoOEhYaHiImKi4yN%0Ajo+QkZKTlJWWl5iZmpucnZ6foKGio6SlpqeoqaqrrK2ur7CxsrO0tba3uLm6%0Au7y9vr/AwcLDxMXGx8jJysvMzc7P0NHS09TV1tfY2drb3N3e3+Dh4uPk5ebn%0A6Onq6+zt7u/w8fLz9PX29/j5+vv8/f7/AAMKHEiwoMGDCBMqXMiwocOHECNK%0AnEixosWLGDNq3Mixo8ePIEOKHEmypMmTKFOqXMmypcuXMGPKnEmzps2bODch%0AUJBrJy6fP3kGzblvgIBcRnElVXqUKVF9S29FrTWValOpV5/aq0qLqyyvX7Na%0A1YoPbCyzr9CmFduVLdl4av9dxWU1l67bsG+33j27dy3Svn7z0qu7inAqw4cB%0Ay1UsGB1iVI9NRZbM2G7jeZNLZR61mXPlwp8vj+ssijQo06dDJxYNVzVk15T/%0Aymb9DvUn251w54Ydm7Y73ZyAaxI+nLdm476zEc+0/FJz58g9J2/33FJ1Stex%0ARy+9fTq17JPARxI/vntq7+vIQ1LviH1787fho3/mvlH9Rffxy989P11+Rf8h%0AEqCA+wVXYH/KDHiIgoUw2OCBxSF4joOEUCiIhRdCyJyGEhaDIQAYfigihx0O%0AM6JTKGJVIjknqpiiLR+uqEqLMJJonY2VxCjja7PV2KOPO4JD41gvEhmkN0O2%0A9aP/kUdyk+QsT0KJY5NLKunilUBSuU2UfFUppZZOThmemOV5iReY2nAJi5pr%0AkonmmVhaGaecb1rD5mJmdlnnNXe20qefbu6JZ5FfElqooN8F+kiIir6XJ6LM%0A/Anao4FBKo2kMzZqn6aM6GgpJpiuZiicn9LHqX6j6jlnqcuEymOqbbIKjaun%0A0FrrqbKeB+ugq5Kaa4K4JsIopbz+Ciyxlu1arLHI2Hocsskym4yzpFBbbbDS%0Abghtpttym22z2C4Y7oPdivqtMdZyV+6r53o4Lrm9qppluya+W6G9Ga57K73u%0A6vussoDyS0y6oRBcML4Cd4owiAgbrGvCwDjsicQTLwwx/4H+Xpuxxhf/QrGB%0AG0vXsS8fb1KyyRaPfG/IB7Pcssq8nKwtwNHC7PLDTOZMp83xxtpzpfPyHPTO%0Ahw5dtNA6H6300r4izbS8RD/ts9NJN2311VBTnbXUy0aNtdY1Vz210V+D7e3P%0AAdM8qdlld9122miz3Vvca9Ndt9xuv3232GPjHbbXfQMeuN/mkj243nsTXjjf%0AeW+NuOIV3xy52mdDvrjgjR/uuOUi230515lzjjPjcBuuueijY1466auj3rnp%0Aocfeuusve84u7LLTPrPt+1L+ue6T8z437rMDz5/vvQs/vPHxSX688v8ynzro%0Af1NfvfQRIr+86sVjD+rCw2q/vf/3uxOfuPXnkw+d8yCLH7362UP/OuvXw68d%0A+yjjn7/98ZtfOf3p458kZPY9/fVPgDkCX8MUaEDsEXB97uMYAm/UQAjKb34T%0AHCADL6iuCGbwgRT0YAczeD8RTu9xvyPhpioYQg7WToVlMmHzZDhDGMbQhTX0%0A3/9suEIaPk+HKeQhxnzYPhzmUIgKY2EClbhEJDqKiPszYvCciCooHpB79aPi%0AyqxYPgDuUIuGAGETpfhDMIqLiWNCYxrNKKwNAvF2XhSiGEtIxiKyMYxujCMc%0AsejEOa6xjlG8I7wA2UU+flGQftSgGhUpSDwucj151KMNE3nDNyavkYOgJCQf%0AuUlMbpH/kAXkYiEbqclFRdKQcjwlCveIPiSW8omgDKUn8yVKC1pyfIhU5eZO%0ABzRPvrKHsbSlL3XJy9wFkI2/TGIthYnJZFYxmC2cpTMBRMxianGabeSkKWeZ%0A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%0AJZudmDc8MmRmYVpdVmKKOH5/fVZ7L1R2MAAAAAAAAAAAAAAAAAAAAAAAAAAA%0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAf/gACCg4SFhoeIiYqD%0AAgKLj5CRh42SlZaIlJeampmbnpGdn6KPoaOmhKWnpqmqo6ytn6+worKzl7W2%0Akri5oI68tL6/rsHCnMTFlbvImMfLvc6eytCozdOJ0tYA2Nbb2drV3obdzuPk%0A4OHU6M/q1+fq5cvwyPLm7O32k+7v+uj08fzh/PESOBCgN4LCENpSCIthQ4PZ%0AHC6EyI0iNImqMJ7S2IrjMHziLF4UWQ8kM5OFPMYi+Q9lOpcpWc6TmZBmTZiC%0AVJo6wAAnAJ44gQbtOdSn0aNIkypdyrSp06dQo0qdSrWq1atYs2rdyrWr169g%0Aw4odS7as2bNo06pdy7at27dw/+PKnUu3rt27ePPq3cu3r9+/gAMLHky4sOHD%0AiBMrXsy4sePHkCNLnky5suXLmDNr3sy5s+fPoEOLHk26tOnTqFOrXs26tevX%0AsGPLnk27tu3buHPr3s27t+/fwIMLH068uPHjyJMrX868ufPn0KNLn069uvXr%0A2LNr3869u/fv4MOLH0++vPnz6NOrX8++vfv38OPLn0+/vv37+PPr38+/v///%0AAAYo4IAEFmjggQgmqOCCDDbo4IMQRijhhBRWaOGFGGao4YYcdujhhyCGKOKI%0AJJZo4okopqjiiiy26OKLMMYo44w01mjjjTjmqFonOiUTTI/rfGMSjzY9xEiR%0AE/kCZP8vSiK5USZLQtJIk0NC6eQslAwQpZSOaHnlKl1uSUqYX4IJgJc4NUKA%0Ali6pyWaVa5YJZpxtCkCnT3YOkOaaMOW5p5598mmUnB3hOeihSQkKk6IoMdoo%0AoItC6pOjJlGKj6WXSvooUpja06k6n4KqaaWjuhQqOqd6k6qqpWbKaauewirq%0ApLLOepQEKPiEK0678pqrr0gVIIJPwuJUrLHDIvsqrTitmo2z1kA7jQMGALBm%0AAySYRK21A2AL0rbXZvttteFqS2634qJkQAELrInAASat2+4A74Ikr7vw2ssu%0A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%0A0fbu4QHYLmAygtyKGbTi719BegofSqwHsdrCbAgpJrQ4MWJHZxk5fiw3cCSr%0Ahj4u/2I8UQBBs5a8YMZ0ObOZzZs4c+rcybOnz59AgwodSrSo0aNIkypdyrSp%0A06dQo0qdSrWq1atYs2rdyrWr169gw4odS7as2bNo06pdy7at27dw48qdS7eu%0A3bt48+rdy7ev37+AAwseTLiw4cOIEytezLix48eQI0ueTLmy5cuYM2vezLmz%0A58+gQ4seTbq06dOoU6tezbq169ewY8ueTbu27du4c+vezbu379/AgwsfTry4%0A8ePIkytfzry58+fQo0ufTr269evYs2vfzr279+/gw4sfT768+fPo06tfz769%0A+/fw48ufT7++/fv48+vfz7+///8AcrUDSjEMqFI+TRCYSf+CByLIBAlBKLhH%0AhA2SQSFJF/ZjAwwwCCDhHgB4WCEZIX4oSgkicpQiCQN4qFCLI5IB44suWjTj%0ACC22k2MxO/IogI4/vmBTjFQMaWQKPd6S5CxLMhlkLks2CYuUqlBZ5ZNKYgmA%0AlaFwyYiXX2rpJApgFlLmH2eiKeaUWqbZh5t2wBnnmqxESeeVvMg5h55w2NkM%0An2kAGuidXbZJKCaCjpGoooeGSWajZkKq5p+STnrComBgmoWmm1b6pqGU5ump%0AHpxa4aeoqKYKJaiq1lLqFK8+ceqqrbo66pyPhkprrWNeeuuev7YRqxPDLjFr%0AlryyqasJxSrRrBHPQhussKzuimyqsnVWe+223NqaK7aFLttttEOQ24O55047%0AqAgRELClAAlAMEu778YLC70t2nuvu/nKu2+9EBCgwAEtGlDALAITLIDBsCRc%0A8MEND/wwwhIvfLDBAzjAwAG1YKwxx7B4vHHHBWQ88iwic5zAAgso4G4tK7f8%0AMiwxu3xLzTPTzLLNIjzQgAG8+Az0LUIH/bPRQ4uAALo5LK0uGE7zEnUuU5vw%0AtBlXg5G11jY9GQIAIfkEAQwAAAAslQBvAPIAxgCkAP8A////39/fICAgr6+v%0Aj4+PUFBQ9/f37+/v19fXGBgYEBAQKCgoAAAAl5eXcHBwMDAwWFhYAAAAAAAA%0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABf8gIAaBaJ5o%0Aqq5sa5JuLM8pTN/4aud8vo+lnpD2GxpVxaPyFVw6gajk0yid9qpWHjaLK265%0AxCb4Kh5ry+Zu+ZtusdtINFz2nkfXcrs7r4/3w38zXnyBJ3V9h4iEhVCGi4yJ%0AdpGSj4WDjC6TcJqblYGXmCycaaOknn+goX6qNaeKrKtMsK2zjrW2t42yuQCl%0AY76/rnqpt8BcxsfClHe8vcqdzchZxLXSU9bXz9C4udhO3t/abdSz4Erm5+Km%0AzLzoVOpm7u/s3fBg8kP4QuSw+mfR9u7hAdguYDKC3IoZtOLvX0F6Ch9KrAex%0A2sJsCCkmtDgxYkdnGTl+LDdwJKuGPi7/YjxRAEGzlrxgxnQ5s5nNmzhz6tzJ%0As6fPn0CDCh1KtKjRo0iTKl3KtKnTp1CjSp1KtarVq1izat3KtavXr2DDih1L%0AtqzZs2jTql3Ltq3bt3Djyp1Lt67du3jz6t3Lt6/fv4ADCx5MuLDhw4gTK17M%0AuLHjx5AjS55MubLly5gza97MubPnz6BDix5NurTp06hTq17NurXr17Bjy55N%0Au7bt27hz697Nu7fv38CDCx9OvLjx48iTK1/OvLnz59CjS59Ovbr169iza9/O%0Avbv37+DDix9Pvrz58+jTq1/Pvr379/Djy59Pv779+/jz69/Pv7///wBytQNK%0AMQyoUj5NEJhJ/4IHIsgECUEouEeEDZJBIUkX9mMDDDAIIOEeAHhYIRkhfihK%0ACSJylCIJA3ioUIsjkgHjiy5aNOMILbaTYzE78iiAjj++YFOMVAxpZAo93pLk%0ALEsyGWQuSzYJi5SqUFnlk0piCYCVoXDJiJdfaukkCmAWUuYfZ6Ip5pRaptmH%0Am3bAGeearERJ55W8yDmHnnDY2QyfaQAa6J1dtkkoJoKOkaiih4ZJZqNmQqrm%0An5JOesKiYGCahaabVvqmoZTm6akenFrhp6iopgolqKrWUuoUrz5x6qqtujrq%0AnI+GSmutY156656/thGrE8MuMWuWvLKpqwnFKtGsEc9CG6ywrO6KbKqydVZ7%0A7bbc2portoUu2220Q5Dbg7nnTjuoCBEQsKUACUAwS7vvxgsLvS3ae6+7+cq7%0Ab70QEKDAAS0aUMAsAhMsgMGwJFzwwQ0P/DDCEi98sMEDOMDAAbVgrDHHsHi8%0AcccFZDzyLCJznMACCyjgbi0rt/wyLDG7fEvNM9PMss0iPNCAAbz4DPQtQgf9%0As9FDi4AAujksrS4YTvMSdS5Tm/C0GVeDkbXWNj0ZAgAh+QQBDAAAACyVAIsA%0A8gDPAKQA/wD////f398gICCvr6+Pj49QUFD39/fv7+/X19cYGBgQEBAoKCgA%0AAACXl5dwcHAwMDBYWFgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%0AAAAAAAAAAAAAAAAF/yAgBoFonmiqrmxrkm4szylM3/hq53y+j6WekPYbGlXF%0Ao/IVXDqBqOTTKJ32qlYeNosrbrnEJvgqHmvL5m75m26x20g0XPaeR9dyuzuv%0Aj/fDfzNefIEndX2HiISFUIaLjIl2kZKPhYOMLpNwmpuVgZeYLJxpo6Sef6Ch%0Afqo1p4qsq0ywrbOOtba3jbK5AKVjvr+ueqm3wFzGx8KUd7y9yp3NyFnEtdJT%0A1tfP0Li52E7e39pt1LPgSubn4qbMvOhU6mbu7+zd8GDyQ/hC5LD6Z9H27uEB%0A2C5gMoLcihm04u9fQXoKH0qsB7HawmwIKSa0ODFiR2cZOX4sN3Akq4Y+Lv9i%0A3EjS5EmVT/i9dKkKpZqKLTXq9LhrZ06fP3XxFAm0X8miNWGGCwmSJiabN6AC%0AYmnU6VOlS2QmtQoJazoUBRA0C8uLbFmxZ5upXcu2rdu3cOPKnUu3rt27ePPq%0A3cu3r9+/gAMLHky4sOHDiBMrXsy4sePHkCNLnky5suXLmDNr3sy5s+fPoEOL%0AHk26tOnTqFOrXs26tevXsGPLnk27tu3buHPr3s27t+/fwIMLH068uPHjyJMr%0AX868ufPn0KNLn069uvXr2LNr3869u/fv4MOLH0++vPnz6NOrX8++vfv38OPL%0An0+/vv37+PPr38+/v///AAYo4IAEFmjggQgmqOD/ggw26OCDEEYo4YQUVmjh%0AhRhmqOGGHHbo4YcghijiiCSWaOKJKKao4ooO7iCVKE28GIuMM3rlkDMkBEFj%0AKzraqEaPJAFpFJAwCLAjLUb6eFOSHDHZEpMkDGCkQlIqqUaVVE5pEZYjSNmO%0Al8WAGaYAX5L5glpWXoHmmimIeYubs8AZp5m5wCknLHeqkqeedL7ZJwB7hhIo%0AI4MS+uecKBRaiKJ/MNrooXj+6Wgfk9pRqaWQsmJnpnzycukcn8KxaTOhplGq%0AqZwKKmmqmJw6hquvsmpoorIuWuujpN6K6wmwgtFrFr8Cqyulq+bq6bB6BGvF%0AqMc262ydxT5bi7JTUPsE/7PQSjstspjSamy22iLKK7egktuGtU6guwS2foYb%0A6bcmqKuEvEbQW6+550YLbrvuaqovvwAHvK23/aoKr8D2DpFwDwszjC+qBO87%0AcMEGj3uwuBJPHO/DZjScg8cfcxxrxAK/S3Gr/2qs8soYiwAyDi/TELPMIvua%0Acss452zyxhfvXLLPgNbMxcwyEF200MKKEAEBQScAwSxLN/00K1FL6TTUTFs9%0ANdVZC+A0AQocIKUBBcwCttgCkA3L2WOXvXbYbZsNd9plkz2AAwwcUIvdeOsN%0AC995713A3YHPArjeCSywgAJM15L44o3D8jjjt0weueSKUy7CAw0YwAvnnt8C%0A+iHnnZMeuggIGO1C6kg/wTovr+cSuwmtW1H7E7fjrhadIQAAIfkEAZYAAAAs%0AlQCwAPIA0ACkAP8A////39/fICAgUFBQr6+vj4+P7+/v9/f3v7+/EBAQ19fX%0AGBgYQEBAMDAwAAAAKCgol5eXcHBwWFhYAAAAAAAAAAAAAAAAAAAAAAAAAAAA%0AAAAAAAAAAAAAAAAAAAAABf8gIAaBaJ5oqq5sa5JuLM8pTN/4aud8vo+lnpD2%0AGxpVxaPyFVw6gajk0yid9qpWHjaLK265xCb4Kh5ry+Zu+ZtusdtINFz2nkfX%0Acrs7r4/3w38zXnyBJ3V9h4iEhVCGi4yJdpGSj4WDjC6TcJqblYGXmCycaaOk%0Ann+goX6qNaeKrKtMsK2zjrW2t42yuQClY76/rnqpt8BcxsfClHe8vcqdzchZ%0AxLXSU9bXz9C4udhO3t/abdSz4Erm5+KmzLzoVOpm7u/s3fBg8kP4QuSw+mfR%0A9u7hAdguYDKC3IoZtOLvX0F6Ch9KrAex2sJsCCkmtDgxYkdnGTl+LDdwJKuG%0APi7/YtxI0uRJlU+KNGjQbCYvmzdp5kSRIEGznryABvU5tGJLjUg97kp6lGlT%0AXUpFOu1XcqoqlGpCgnQZCusNr4BYUuXaFWY4o2OtXjW7pIiBA83e8pI7F27d%0AZnjz6t3Lt6/fv4ADCx5MuLDhw4gTK17MuLHjx5AjS55MubLly5gza97MubPn%0Az6BDix5NurTp06hTq17NurXr17Bjy55Nu7bt27hz697Nu7fv38CDCx9OvLjx%0A48iTK1/OvLnz59CjS59Ovbr169iza9/Ovbv37+DDix9Pvrz58+jTq1/Pvr37%0A9/Djy59Pv779+/jz69/Pv7///wAGKOCABBZo4IEIJqjg/4IMNujggxBGKOGE%0AFFZo4YUYZqjhhhx26OGHIIYo4ogklmjiiSimqOKKLLbo4oswxijjjDTWaOON%0AOJa4A1iiNMFjLD8CyRYZTJAQRJCtHDlkSkqS1CRVTcIgAJK0TLlkSgBYyZGW%0ALWlJwgBTKgTmlSmNKWaYFpk5ApjtsFmMm28K0KacL+BF5j525pkCnLfwOYuf%0Af9KZi5+AwlKoKociKmifiwKQaCiPMhKppI0GisKkhWD6h6abVmpoo5z2Eaod%0Ao5LqKSuEnqooL6XO0SocqTbzahqz0qoqpKDeikmtY/Daq66UXgpspsN2Kmux%0Axp7gKxjLZtGss8iKmuuxrEarx/+zVsRa7bbcDjptt7VgO4W4T2jrLbjhWmuq%0AsNSei66lyqrrqrxtkOuEvUuYy+i7n7ZrAr5KAGyEwAPTW++37u7LL6oIK+zw%0Aw+myuzCu/kJM8BAX95CxxgbbKnHCEU9McbwVwwtyyP92bMbGObDcssq/fgxx%0AvyLv2jDKOOdssggu49AzDT8DDTOzN+9s9NE0p1xy0jMz7ejQXAQtg9RTQw2t%0AzDozvDTNExTw9AIOzNL112GzMjaYYIvtNdplm722AGAXwAACYBJgwCxy0y2A%0A3bDkXffdfc/9N96C73233QNEAAECtSCuOOOwOL544wYkPvkskjO+gAIKMOB1%0ALZt3/jk3LKF7fkvpo5POuekiSPAAAby4Dvstssf+uu2zi3AA1S7sbvUTvvMS%0AfC7Dm/C7Fcc/kbzyeAkaAgA7)

​								CountDownLatch运行机制

**数据构建和核心参数**

![img](https://upload-images.jianshu.io/upload_images/6050820-b93909094116df2f.png?imageMogr2/auto-orient/strip|imageView2/2/w/524/format/webp)

​								CountDownLatch继承关系

从锁的类别来说，CountDownLatch是一个“**共享锁**”，内部定义了自己的同步器Sync，Sync继承自AQS，实现了tryAcquireShared和tryReleaseShared两个方法，需要注意的是，**CountDownLatch中锁是响应中断的，如果线程在对锁进行操作期间发生中断，会直接抛出InterruptedException**。

```java
//构造函数
public CountDownLatch(int count){
    if(count < 0) throw new IllegalArgumentException("count < 0");
    this.sync =new Sync(count);
}
//CountDownLatch中的计数其实就是AQS的state
Sync(int count){
    setState(count);
}
```

从构造函数中可以看出，CountDownLatch的“锁计数”，本质上就是AQS的资源数state。下面在通过await()和countDown()两个方法来分析CountDownLatch的latch实现。

```java
public void await()throws InterruptedException{
    sync.acquireSharedInterruptibly(1);
}
//AQS中acquireSharedInterruptibly(1)的实现
public final void acquireSharedinterruptibly(int arg)
					throws InterruptedException{
	if(Thread.interrupted()){
        throw new InterruptedException();
	}
	if(tryAcquiresShared(arg)<0){
        doAcquireSharedInterruptibly(arg);
	}
}
//tryAcquireShared在CountDownLatch中的实现
protected int tryAcquireShared(int acquires){
        return (getState()==0) ? 1: -1;
}
```

await()的实现就是通过对资源state剩余量（state==0 ？1 ： -1）来判断是否获取到锁。在AQS中，tryAcquireShared方法规定了它的返回值类型：**成功获取并且还有可用资源返回正数；成功获取但是没有可用资源时返回0；获取资源失败返回一个负数。**也就是说，只要state！=0，线程就进入等待队列阻塞。

```java
public void countDown(){	
    sync.releaseShared（1）；
}
//AQS中acquireSharedInterruptibly（1）的实现
public final boolean releaseShared(int arg){
    if(tryReleaseShared(arg)){
        doReleaseShared();
        return true;
    }
    return false;
} 
//tryReleaseShared在CountDownLatch中的实现
protected boolean tryReleaseShared(int releases){
    for(;;){
        int c = getState();
        if(c ==0 )
        	return false;
        	int nextc = c-1;
        	if(compareAndSerState(c,nextc))
        	return nextc == 0;
    }
}
```

如果释放资源后state ==0，说明已经达到latch，此时就可以调用doReleaseShared唤醒等待线程。

#### CyclicBarrier的实现

CyclicBarrier是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点（common barrier point）。如果一个程序中有固定的线程数，并且线程直接需要相互等待，这时候CyclicBarrier是一个很好的选择。之所以叫Cyclic，是因为在释放等待线程之后，它可以被重用。

![img](data:image/gif;base64,R0lGODlhkgGpAWYAACH5BAAMAAAAIf8LTkVUU0NBUEUyLjADAQAAACwAAAAA%0AkgGpAab////3lka/v79AQEDf398gICAAAADYgz0/ODG5cDT39/evras3MCrU%0AVRDPz88nHhd/fHmwlkZPSUPv7+9ONSHgiD/JejnojULBdTeaXiwvIhjX19cA%0AAByXlZNgWlUvKiVlQSPvkUQ3KBuwPACqaTRQUFCqZzA3KiAYFBEfGBIQDAl8%0ATil7SyOPjYyiYi6LViu3tbOem5ixbDLn5+fHx8d8UCtHQjxja0ZYUk4YGBgQ%0AEBA+LB0nIBp/endwbGkoKCgvJyF4dXI/MCMwMDA4VTySWSmDUSgAABAIBgU4%0AABwAPDIAIif3axyLgEZXUUxYWFhoZGFgYGBoaGhwcHBdPSNGMR/UlkaiZDJt%0ARib3gCcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH/4AAgoOEhYaHiImKi4yC%0ABQSNkZKTlJWWl5iZmpucnZ6foKGNj6KlpqeoqaqrrK2uhKSvsrO0tba3uKix%0Auby9vr/AwZ67wsXGx8jJrcTKzc7P0NGDzNLV1tfYy5DZ3N3e35bU4OPk5dfi%0A5unq68Do7O/w8avu8vX295j0+Pv8/bDb/gIK7KdvoMGD4woiXMiwmsKGECMe%0AeyixosVcFC9q3KiNo8ePsp4sAPBowxCQKFOWWpBDwaMSLVTKnLkJZoEOPxTQ%0A3MlT0gYdOnKM7Em06KEpBkoYXcp0QkamUDUCjEq1qtWrWLNq3cq1q9evYMOK%0AHUu2rNmzaNOqXcu2rdu3cP/jyp1Lt67du3jz6t3Lt6/fv4ADCx5MuLDhw4gT%0AK17MuLHjx5AjS55MubLly5gza97MubPnz6BDix5NurTp06hTq17NurXr17Bj%0Ay55Nu7bt27hz697Nu7fv38CDCx9OvLjx48iTK1/OvLnz59CjS59Ovbr169iz%0Aa9/Ovbv37+DDix9Pvrz58+jTq1/Pvr379/Djy59Pv779+/jz69/Pv7///wAG%0AKOCABBZo4IEIJqjgggw26OCDEEYo4YQUVmjhhRhmqOGGHHbo4YcghijiiCSW%0A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%0AMpJhIBtyaOGBFnb4h4h6kFjih7AE2AAEz6zIi4svshgjCgZQ8EyNvOCYo407%0AYojiggT+GKGQocw3AQEAeKcAA7McmaQAS8LipJJMSokklU1eCSUDBBiAgHcF%0AHDBLl18KECYsZIIpJppeqjlmm2aKGeYAETyAQC1z1nknLHnaiecBdPo5S593%0AKrDAAgYgWYuhiCoKC6OJ3gKpo48eGqkIEjhQAC+ZbnpLp5xqGqqnIiRg4hym%0AEllIqrywmourJqiKiayF0FrrNQyGAAAh+QQBDAAAACxNAEAA8gC9AKQA/wD/%0A///f398gICCvr6+Pj49QUFD39/fv7+/X19cYGBgQEBAoKCgAAACXl5dwcHAw%0AMDBYWFgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%0AAAAF/yAgBoFonmiqrmxrkm4szylM3/hq53y+j6WekPYbGlXFo/IVXDqBqOTT%0AKJ32qlYeNosrbrnEJvgqHmvL5m75m26x20g0XPaeR9dyuzuvj/fDfzNefIEn%0AdX2HiISFUIaLjIl2kZKPhYOMLpNwmpuVgZeYLJxpo6Sef6Chfqo1p4qsq0yw%0ArbOOtba3jbK5AKVjvr+ueqm3wFzGx8KUd7y9yp3NyFnEtdJT1tfP0Li52E7e%0A39pt1LPgSubn4qbMvOhU6mbu7ygFCM31vPj59vvN/v8AAwocSLCgwYMIEypc%0AyLChw4cQI0qcSLGixYsYM2rcyLGjx48gQ4ocSbKkyZMoU/+qXMmypcuXMGPK%0AnEmzps2bOHPq3Mmzp8+fQIMKHUq0qNGjSJMqXcq0qdOnUKNKnUq1qtWrWLNq%0A3cq1q9evYMOKHUu2rNmzaNOqXcu2rdu3cOPKnUu3rt27ePPq3cu3r9+/gAML%0AHky4sOHDiBMrXsy4sePHkCNLnky5suXLmDNr3sy5s+fPoEOLHk26tOnTqFOr%0AXs26tevXsGPLnk27tu3buHPr3s27t+/fwIMLH068uPHjyJMrX868ufPn0MXu%0AkKdml6rp8LJZv96EhHdd3INQDyM++5PvzsrZgAFDwPgb7d8LKuHe/Hn68ucD%0AqO9sgPtiAfhnXzgCAlhgNQH+N4L/f+0wWIyDDwrQoIQv+DOgFRdiaKEKEN7S%0A4SwfgkhhLh+GCIuJqqCY4ogesgiAiqHAyIiMM7ooIgo0FpLjHzvyaOOJLvbY%0Ah5B2EFnkj6yUiOSKvBg5h5NwKNkMlGlQWeWSMQaJJSZWjtGll1vWiGOYOpLp%0A45RmnnnCl2CwmYWbb6Y5pJZoNimnHnBaIaWdfPZJIp1+1pLnFIM+4WAEBLwo%0AQAIQzIKooozC8qh/kUqaKKWNWgopBAQocIB/BhQwS6efChAqLKSCKiqqnqo6%0AaqumihrqAA4wcEAts9Z6Kyy52oprAbT6OkuvtyawwAIKJFqLscgqCwuzyd4C%0ArbPPHhutLAgPNGAAL9lue0u33GobrrciIFDoEubeCUe6vLCbi7smqGuHvHDQ%0AW68/I4YAACH5BAEMAAAALE0AUwDyAMIApAD/AP///9/f3yAgIK+vr4+Pj1BQ%0AUPf39+/v79fX1xgYGBAQECgoKAAAAJeXl3BwcDAwMFhYWAAAAAAAAAAAAAAA%0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAX/ICAGgWieaKqubGuS%0AbizPKUzf+GrnfL6PpZ6Q9hsaVcWj8hVcOoGo5NMonfaqVh42iytuucQm+Coe%0Aa8vmbvmbbrHbSDRc9p5H13K7O6+P98N/M158gSd1fYeIhIVQhouMiXaRko+F%0Ag4wuk3Cam5WBl5gsnGmjpJ5/oKF+qjWniqyrTLCts461treNsrkApWO+v656%0AqbfAXMbHwpR3vL3Knc3IWcS10lPW18/QuLnYTt7f2m3Us+BK5ufipsy86FTq%0AZu7v7N3wYPJD+ELksPpn0fbu4QHYLmAygtyKGbTi719BegofSqyHogCCZhZ5%0AZdR4kWOzjyBDihxJsqTJkyhT/6pcybKly5cwY8qcSbOmzZs4c+rcybOnz59A%0AgwodSrSo0aNIkypdyrSp06dQo0qdSrWq1atYs2rdyrWr169gw4odS7as2bNo%0A06pdy7at27dw48qdS7eu3bt48+rdy7ev37+AAwseTLiw4cOIEytezLix48eQ%0AI0ueTLmy5cuYM2vezLmz58+gQ4seTbq06dOoU6tezbq169ewY8ueTbu27du4%0Ac+vezbu379/AgwsfTry48ePIkytfzry58+fQo0ufTr269evYs2vfzr279+/g%0Aw4sfT768+fPo06tfz769oCYN6cBfeGRH/Bj26defTyLI/Uw2/CdKgPq941+B%0A+RDoDP8AAgi4B4MO6lBCgwgmCGGF+0wIAwkDNKhQhxiSAeKHHlYTwIgjdNiO%0AisWw2KIAK8L4wkchUkHjjSm4eIuOs/DYo4y58OgjLEOqUqSRQO6YJABHhtIk%0AI09CueSPKERZiJV/YJnllEQuqWUfX9oRpphcsiJkmUjyMuYca8JxZjNtphGn%0AnGg66WWdmMw5hp574illlX5eGeiWcA5K6Al8gpFoFosyaiiYdxaq5qN6NGrF%0Am5NmqmmQkW5ai6VTgPoEppx6+imlZAIqaammUokoqmzC2oaoTtC6BKlKttrl%0AqibYqoSvRgAbrKyzyhgBAUwKkAAEsxyb7LKwONshtNEiOy17s9U+CwEBChzQ%0AoQEFzMKttwKAC8u434Z7brfpistuueGCO4ADDBxQi7z02gsLvvXeW8C8/c7C%0Ar70JLLCAAsjWUvDBCcOyMMK3PNywwwZDLMIDDRjAC8Ya38LxxhmD3LEICAgr%0ARMnEjoEyLyvn0rIJKacR8xgz0/wRkCEAACH5BAEMAAAALE0AawDyAMYApAD/%0AAP///9/f3yAgIK+vr4+Pj1BQUPf39+/v79fX1xgYGBAQECgoKAAAAJeXl3Bw%0AcDAwMFhYWAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%0AAAAAAAX/ICAGgWieaKqubGuSbizPKUzf+GrnfL6PpZ6Q9hsaVcWj8hVcOoGo%0A5NMonfaqVh42iytuucQm+Coea8vmbvmbbrHbSDRc9p5H13K7O6+P98N/M158%0AgSd1fYeIhIVQhouMiXaRko+Fg4wuk3Cam5WBl5gsnGmjpJ5/oKF+qjWniqyr%0ATLCts461treNsrkApWO+v656qbfAXMbHwpR3vL3Knc3IWcS10lPW18/QuLnY%0ATt7f2m3Us+BK5ufipsy86FTqZu7v7N3wYPJD+ELksPpn0fbu4QHYLmAygtyK%0AGbTi719BegofSqwHsdrCbAgpJrQ4MWJHZxk5fiw3cCSrhj4u/2I8UQBBs5a8%0AYMZ0ObOZzZs4c+rcybOnz59AgwodSrSo0aNIkypdyrSp06dQo0qdSrWq1atY%0As2rdyrWr169gw4odS7as2bNo06pdy7at27dw48qdS7eu3bt48+rdy7ev37+A%0AAwseTLiw4cOIEytezLix48eQI0ueTLmy5cuYM2vezLmz58+gQ4seTbq06dOo%0AU6tezbq169ewY8ueTbu27du4c+vezbu379/AgwsfTry48ePIkytfzry58+fQ%0Ao0ufTr269evYs2vfzr279+/gw4sfT768+fPo06tfz769+/fw48ufT7++/fv4%0A8+vfz7+///8AcrUDSjEMqFI+TRCYSf+CByLIBAlBKLhHhA2SQSFJF/ZjAwww%0ACCDhHgB4WCEZIX4oSgkicpQiCQN4qFCLI5IB44suWjTjCC22k2MxO/IogI4/%0AvmBTjFQMaWQKPd6S5CxLMhlkLks2CYuUqlBZ5ZNKYgmAlaFwyYiXX2rpJApg%0AFlLmH2eiKeaUWqbZh5t2wBnnmqxESeeVvMg5h55w2NkMn2kAGuidXbZJKCaC%0AjpGoooeGSWajZkKq5p+STnrComBgmoWmm1b6pqGU5umpHpxa4aeoqKYKJaiq%0A1lLqFK8+ceqqrbo66pyPhkprrWNeeuuev7YRqxPDLjFrlryyqasJxSrRrBHP%0AQhussKzuimyqsnVWe+223NqaK7aFLttttEOQ24O55047qAgRELClAAlAMEu7%0A78YLC70t2nuvu/nKu2+9EBCgwAEtGlDALAITLIDBsCRc8MEND/wwwhIvfLDB%0AAzjAwAG1YKwxx7B4vHHHBWQ88iwic5zAAgso4G4tK7f8Miwxu3xLzTPTzLLN%0AIjzQgAG8+Az0LUIH/bPRQ4uAALo5LK0uGE7zEnUuU5vwtBlXg5G11jY9GQIA%0AIfkEAQwAAAAsTQCHAPIAywCkAP8A////39/fICAgr6+vj4+PUFBQ9/f37+/v%0A19fXGBgYEBAQKCgoAAAAl5eXcHBwMDAwWFhYAAAAAAAAAAAAAAAAAAAAAAAA%0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABf8gIAaBaJ5oqq5sa5JuLM8pTN/4%0Aaud8vo+lnpD2GxpVxaPyFVw6gajk0yid9qpWHjaLK265xCb4Kh5ry+Zu+Ztu%0AsdtINFz2nkfXcrs7r4/3w38zXnyBJ3V9h4iEhVCGi4yJdpGSj4WDjC6TcJqb%0AlYGXmCycaaOknn+goX6qNaeKrKtMsK2zjrW2t42yuQClY76/rnqpt8BcxsfC%0AlHe8vcqdzchZxLXSU9bXz9C4udhO3t/abdSz4Erm5+KmzLzoVOpm7u/s3fBg%0A8kP4QuSw+mfR9u7hAdguYDKC3IoZtOLvX0F6Ch9KrAex2sJsCCkmtDgxYkdn%0AGTl+LDdwJKuGPi7/YtxI0uRJlU/4vXSpCqWaii016vS4a2dOnz918RQJtF+Z%0AAgiaIeW1lGlSp82iSp1KtarVq1izat3KtavXr2DDih1LtqzZs2jTql3Ltq3b%0At3Djyp1Lt67du3jz6t3Lt6/fv4ADCx5MuLDhw4gTK17MuLHjx5AjS55MubLl%0Ay5gza97MubPnz6BDix5NurTp06hTq17NurXr17Bjy55Nu7bt27hz697Nu7fv%0A38CDCx9OvLjx48iTK1/OvLnz59CjS59Ovbr169iza9/Ovbv37+DDix9Pvrz5%0A8+jTq1/Pvr379/Djy59Pv779+/jz69/Pv7///wAGKOCABBZo4IEIJqjg/4IM%0ANujggxBGKOGEFFZo4XE72JRJExqKwiFM+Xz4EwkkChVKiSC9FESHHq4I4j42%0AwACDACx6CACNL5JxY406lIAjRz+SMACNCg2ZIxlGFkmkRUmOMGQ7TxYTpZQC%0AQFnlC1EdSUWWXKYw5S1fzhKmmFfmEuaYsKCpipprlgmmmwCwGYqcjNBZJ5xk%0AomBnIXv+0aefeKYJ5599EGqHoYcGysqZirbJC6JzQAoHo81ImoallzY656Ca%0AYoLpGJ+C2umdeo7Kp6mAVopqqieECoarWcAa66qFcqrqo7TqIasVlOLq669m%0A2gpsLbtOUewTvQY7LLG5Jlrqrcoum2erzUZabekbxzqR7RLJvimtoNCasK0S%0A4xpRrrnXYitstN5+u+i67cYrL7PPurtpuPOeO4S+PfDbb7qZ1ssuvfbeSy2+%0A0w5MsLgAm+FvDg9D3LCoAs8LbsGewrvwxhxPGwEBcQqQAASzfBzyyLCYPCTK%0AKYO8MsktnwwBAQocMKQBBcxCs80C4AzLzjfn/HPNQetMdM854zyAAwwcUIvS%0ATDsNC9RNP13A0lXPQrXTCSywgAIg19L112HDMjbYt5xdttleoy3CAw0YwAvc%0Act9C99xx4123CAhEfEPfE2cBOC+D51K4CYGDkXgWizMeVZkhAAAh+QQBDAAA%0AACxNAKgA8gDQAKQA/wD////f398gICCvr6+Pj49QUFD39/fv7+/X19cYGBgQ%0AEBAoKCgAAACXl5dwcHAwMDBYWFgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%0AAAAAAAAAAAAAAAAAAAAAAAAF/yAgBoFonmiqrmxrkm4szylM3/hq53y+j6We%0AkPYbGlXFo/IVXDqBqOTTKJ32qlYeNosrbrnEJvgqHmvL5m75m26x20g0XPae%0AR9dyuzuvj/fDfzNefIEndX2HiISFUIaLjIl2kZKPhYOMLpNwmpuVgZeYLJxp%0Ao6Sef6Chfqo1p4qsq0ywrbOOtba3jbK5AKVjvr+ueqm3wFzGx8KUd7y9yp3N%0AyFnEtdJT1tfP0Li52E7e39pt1LPgSubn4qbMvOhU6mbu7+zd8GDyQ/hC5LD6%0AZ9H27uEB2C5gMoLcihm04u9fQXoKH0qsB7HawmwIKSa0ODFiR2cZOX4sN3Ak%0Aq4Y+Lv9i3EjS5EmVT/i9dKkKpZqKLTXq9LhrZ06fP3XxFAm0X8miNWGGCwmS%0AJiabN6ACYmnU6VOlS2QmtQoJazqcVZFu/VgAQbOyvNCmNbu2mdu3cOPKnUu3%0Art27ePPq3cu3r9+/gAMLHky4sOHDiBMrXsy4sePHkCNLnky5suXLmDNr3sy5%0As+fPoEOLHk26tOnTqFOrXs26tevXsGPLnk27tu3buHPr3s27t+/fwIMLH068%0AuPHjyJMrX868ufPn0KNLn069uvXr2LNr3869u/fv4MOLH0++vPnz6NOrX8++%0Avfv38OPLn0+/vv37+PPr38+/v///AAYo4IAEFmjggQgmqOD/ggw26OCDEEYo%0A4YQUVmjhhRhmqOGGHHbo4YcghijiiCSWaOKJKKao4oostujihjtIJUoTMsZS%0Ao41eOeQMCUHc2EqPOaoBJElDGjUkDAL4SEuSQd7EJEdPtvQkCQMkqVCVTaqB%0A5ZVWWrTlCFW2E2YxY5IpgJhnvuBWlles6WYKZd4S5yxz0plmLnPWCYueqvDZ%0A551yAgqAn6EQyoihhwpqJwqIFtLoH49Cquiegkbah6V2YJrppKzkyemfvGg6%0Ah6hweNoMqWmgmuqnhVbKKiaqjhGrrK8mymitjuIq6am67nrCrGAAm4Www/Z6%0Aqau8hmqsHsRaYaqy0EaLJ7LS1tLs/xTXPvHstNVau+ymtybLbbeL/vrtqOe2%0Aka0T6y6xbaDkUiquCe0qUa8R9+KbrrrUjgtvvJ32++/ABHsbLsCtzltwvkMw%0A3IPDD++76sH+GoxwwuYqXG7FFtMrsRkQ5xCyyB/TSnHB8l4Mq8Adt+zyxiKM%0AjIPMNNBcc8nBsgzzzjyn7LHGPqMc9KA4c2GzDEcjXXSxJ78cMNApR0AA0QlA%0AMIvUVFvNCtZVVn311F1rvTXYAlRNgAIHVGlAAbOcnbYAa8Pittpsy4023W3f%0ADTfbaw/gAAMH1NL334HDMjjgghfgN+KzHB54AgssoMDUtUAuOeWwWD75LZpj%0Annnkm4vwQCkDBvAyeum3nG466aujLgICSbsA+9JPzM6L7bngbgLtVvD+hO+/%0Au3VnCAAh+QQBZAAAACxNAM4A8gDBAKQA/wD////f398gICBQUFCvr6+Pj4/v%0A7+/39/e/v78QEBDX19cYGBhAQEAwMDAAAAAoKCiXl5dwcHBYWFgAAAAAAAAA%0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAF/yAgBoFonmiqrmxrkm4s%0AzylM3/hq53y+j6WekPYbGlXFo/IVXDqBqOTTKJ32qlYeNosrbrnEJvgqHmvL%0A5m75m26x20g0XPaeR9dyuzuvj/fDfzNefIEndX2HiISFUIaLjIl2kZKPhYOM%0ALpNwmpuVgZeYLJxpo6Sef6Chfqo1p4qsq0ywrbOOtba3jbK5AKVjvr+ueqm3%0AwFzGx8KUd7y9yp3NyFnEtdJT1tfP0Li52E7e39pt1LPgSubn4qYoDQ3N7bzw%0A8e7zKAkJzfe8+vv4/cy80FFRZ0bgQIDdCIIxOIShEHKwHJ6JpnBhGQMHmmHk%0AtZFjRo/NQoocSbKkyZMoU/+qXMmypcuXMGPKnEmzps2bOHPq3Mmzp8+fQIMK%0AHUq0qNGjSJMqXcq0qdOnUKNKnUq1qtWrWLNq3cq1q9evYMOKHUu2rNmzaNOq%0AXcu2rdu3cOPKnUu3rt27ePPq3cu3r9+/gAMLHky4sOHDiBMrXsy4sePHkCNL%0Anky5suXLmDNr3sy5s+fPoEOLHk26tOnTqFOrXs26tevXsGPLnk27tu3buHPr%0A3s27t+/fwIMLH068uPHjyJMrX868ufPn0KNLn069uvXr2LNr3869u/fv4MOL%0AH0++vPnz6NOrX8++vfv353dIFNRkfgz5FcPtYoWfRBD799kA4B7/5beEf7qo%0AgqD/MwwKMGAmJThoYDoASFhNhA/uUSEMJAzgYDEBeDhhOiKCWOKFJ/biYUAr%0AFtOiiwKwGOMLIY34hI031qjCi7fwOIuPP86Yi49AwlKkKkciKWSPSwKQZChP%0AMhKllE0GicKUhWD5h5ZbVmlkk1z2EaYdY5LpJStEnqkkL2XO0SYcaTbzZhpz%0A0qkmlGDeiUmdY/DZp55UXgloloN2KWehhp7gJxiLZtGoo4iKmeehbEaqx6NW%0AxFnpppwOOWmntWA6hahPaOopqKFaaqaglJ6KqpWKquqmrG2Q6oStS5jK5Ktf%0AtjpBAU4KsIADs/wa7LCwGOshsskCuyyxzR7rQAEMIOAhcQEGzEKttQJgC8u2%0A12b7bbXhaktut9liO0AEECBQi7rsugsLvO2+a8C69c5Cr7sLKKAAA8DW0u+/%0AAcMyMMC3HFywwf4iLIIEDxDAC8QS30LxxBFjXLEIB+B6RMe0mgEyLyPnUrIJ%0AIbeRshkrsxySkCEAADs=)

​								CyclicBarrier运行机制

**CountDownLatch和CyclicBarrier的区别**：

1.CountDownLatch的作用是运行1或N个线程等待其他线程完成执行；而CyclicBarrier则是允许N个线程相互等待。

2.CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，所以也被称为是循环的Barrier。

**CyclicBarrier主要通过独占锁ReentrantLock和condition配合实现。**类本身实现很简单，重点是要分清CyclicBarrier和CountDownLatch的用发和区别。

### 阻塞队列

阻塞队列，指的是当队列容器已满。生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直到队列非空为止，阻塞队列（BlockingQueue）被广泛使用在“生产者-消费者”问题中，主要是因为BlockingQueue提供了可阻塞的插入和移除的方法

BlockingQueue定义：

```java
publiC interface BlockingQueue<E> extends Queue<E> {
    //往队列中插入元素，如果BlockingQueue可以容纳成功返回true
    //否则失败抛出一个illegalStateException异常，所以建议使用offer（Object）
    boolean add (E e);
    
    //插入元素，如果BlockingQueue可以容纳，则返回true；否则返回false
    boolean offer(E e);
    
    //插入元素，如果BlockingQueue没有空间，则调用此方法的线程被阻断直到BlockingQueue里
    //有空间在继续。如果此线程被中断，抛出InterruptedException
    void put(E e)throws InterruptedException;
    
    //插入元素，如果BlockingQueue可以容纳，则返回true否则返回false
    //同事限时阻塞调用线程。直到超时或线程被中断或队列状态不可用
    //如果此线程被中断，抛出InterruptedException
    boolean offer(E e,long timeout, TimeUnit unit)throwsInterruptedException;
    
    //取走BlockingQueue里排在首位的对象，若BlockingQueue为空
    //阻断进入等待状态直到Blocking有新的对象被加入为止
    //如果此线程被中断抛出抛出InterruptedException
    E take()throws InterruptedException;
    
    //取走BlockingQueue里在首位的对象，会限时阻塞调用线程，
    //直到超时或者线程被中断或队列状态不可用
    E pool(long timeout,TimeUnit unit)thorws InterruptedException;
}
```

**实现BlockingQueue接口有：**

ArrayBlockingQueue

DealyQueue

LinkedBlockingDueue

LinkedBlockingQueue

LinkedTransferQueue

PriorityBlockingQueue

SynchronousQueue

这几个都是常见的阻塞队列

##### **ArrayBlockingQueue**

基于数组的阻塞队列实现。在ArrayBlockingQueue内部，维护了一个定长数组（**构造函数初始化数组长度**），以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长的数组外，ArrayBlockingQueue内部还保存这两个整形变量，分别标识这队列的头部和尾部在数组中的位置。

**1.重要属性和构造函数**

``` java
public class ArrayBlockingQueue<E> extends AbstractQueue<E>
implements BlockingQueue<E>,java.io.Serializable｛
	//储存元素的数组
	final Object [] items;
	//下一个去除或删除的元素下标take，poll,peek or remove
	int takeIndex;
	//下一个插入的元素的下标
	int putIndex;
	//数组元素个数
	int count;
	//同步锁
	final ReentrantLock lock;
	//同步条件等待队列（取出）
	private final condition notEmpty;
	//同步条件等待队列（添加）
	private final condition notFull;
	
	//以下三个构造函数，都必须传入初始化数组的大小
	public ArrayBlockingQueue(int capacity){
        this(capacity,false);
	}
	
	public ArrayBlockingQueue(int capacity,boolean fair){
        if（capacity <= 0）throw new IllegalArgumentException();
        this.items= new Object[capacity];
        lock =new ReentrantLock(fair);
        notEmpty = lock.newCondition();
        notFull = lock.newCondition();
	}
	public ArrayBlockingQueue(int capacity, boolean fair,
								Collection<? extends E> c) {
        this(capacity, fair);
        final ReentrantLock lock = this.lock;
        lock.lock(); // Lock only for visibility, not mutual exclusion
        try {
            int i = 0;
            try {
                for (E e : c) {
                    checkNotNull(e);
                    items[i++] = e;
                }
            } catch (ArrayIndexOutOfBoundsException ex) {
                throw new IllegalArgumentException();
            }
            count = i;
            putIndex = (i == capacity) ? 0 : i;
        } finally {
            lock.unlock();
        }
    } 
｝
```

**2.添加方法put(),offer(),add()区别**

1.put方法

```java
public void put(E e) throws InterruptedException {
  		//校验元素是否为空，为空抛出异常
        checkNotNull(e);
        final ReentrantLock lock = this.lock;
  		//加锁（此锁响应中断）
        lock.lockInterruptibly();
        try {
          	//如果元素数量达最大，则当前线程进入条件等待队列
          	//等待items.length < count 或唤醒
            while (count == items.length)
                notFull.await();
          	//count != items.length 正常添加元素，这方法里面添加元素成功后会调用				notFull.signal()
          	//唤醒等待的线程
            enqueue(e);
        } finally {
            lock.unlock();
        }
    }
```

**2.offer方法**

```java
public boolean offer(E e) {
        checkNotNull(e);
        final ReentrantLock lock = this.lock;
  		//加锁，不响应中断
        lock.lock();
        try {
          	//如果元素数量达最大，则直接返回false
            if (count == items.length)
                return false;
            else {
                enqueue(e);
                return true;
            }
        } finally {
            lock.unlock();
        }
    }
```

**3.add方法**

```java
 public boolean add(E e) {
        return super.add(e);
 }
//这个方法很简单，直接调用的suer.add方法，即AbstractQueue.add方法，如下
public boolean add(E e) {
  		//调用的offer方法，添加失败抛出异常，添加成功返回true
        if (offer(e))
            return true;
        else
            throw new IllegalStateException("Queue full");
 }
```

**3.poll(),take()区别**

**1.poll()方法**

```java
 public E poll() {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            return (count == 0) ? null : dequeue();
        } finally {
            lock.unlock();
        }
    }
```

**2.take() 方法**

```java
public E take() throws InterruptedException {
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            while (count == 0)
              	//没有元素了，阻塞取元素的线程
                notEmpty.await();
            return dequeue();
        } finally {
            lock.unlock();
        }
    }
```

**总结：**

1、ArrayBlockQueue是有限队列，长度在构造函数中初始化。

2、put添加元素方法，如果元素个数达到最大值，会将添加元素线程挂起，等待take或者poll方法唤醒。

3、take获取元素，如果队列为空了，会阻塞获取元素的线程，在put或者offer方法中唤醒。

4、ArrayBlockQueue的同步锁是用的一个ReentrantLock锁，所以，添加和获取是无法同步进行的。

##### **LinkedBlockingQueue**

LinkedBlockingQueue是**单向链表结构的自定义容量的阻塞队列**，元素按照**FIFO（先进先出）**的顺序，使用显式锁ReentrantLock和Condition来保证线程安全，并且内部是不会自动扩容的，如果未指定容量，将取最大容量Integer.MAX_VALUE。

1.重要属性和构造函数

```java
public class LinkedBlockingQueue<E> extends AbstractQueue<E>
implements BlockingQueue<E> ,java.io.Serialezable{
     //链表节点元素
     static calsee Node<E>{
          E item;
          Node<E> next;
          Node(E x){item =x ;}
      }
      //链表长度，默认Integer.MAX_VALUE
      private final int capacity;
      //当前元素个数
      private final AtomicInteger count= new AtomicInteger();
      //链表头节点
      transient Node<E> head;
      //链表尾节点
      private transient Node<E> last;
      //获取元素同步锁
      private final ReentrantLock takeLock = new ReentrantLock();
      //获取元素条件等待队列
      private final Condition notEmpty = takeLock.new Condition();
      //添加元素同步锁
      private final  ReentrantLock  putLock = new ReentrantLock();
      //添加元素条件等待队列
      private final Condition notFull = putLock.newCondition();
      
      public LinkedBlickingQueue(){
          this(Integer.MAX_VALUE);
      }
      
      public LinkedBlockingQueue(Collection<? extends E> c) {
        this(Integer.MAX_VALUE);
        final ReentrantLock putLock = this.putLock;
        putLock.lock(); // Never contended, but necessary for visibility
        try {
            int n = 0;
            for (E e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (n == capacity)
                    throw new IllegalStateException("Queue full");
                enqueue(new Node<E>(e));
                ++n;
            }
            count.set(n);
        } finally {
            putLock.unlock();
        }
    }

}
```

2.添加方法put(),offer() 区别

**1.put(）方法**

```java
 public void put(E e) throws InterruptedException {
        if (e == null) throw new NullPointerException();
        // Note: convention in all put/take/etc is to preset local var
        // holding count negative to indicate failure unless set.
        int c = -1;
        Node<E> node = new Node<E>(e);
        final ReentrantLock putLock = this.putLock;
        final AtomicInteger count = this.count;
        putLock.lockInterruptibly();
        try {
          	//如果元素个数 等于最大值，阻塞添加元素的线程
            while (count.get() == capacity) {
                notFull.await();
            }
            enqueue(node);
            c = count.getAndIncrement();
          //元素添加成功，当前元素个数+1小于最大值，唤醒正在等待添加元素线程
            if (c + 1 < capacity)
                notFull.signal();
        } finally {
            putLock.unlock();
        }
        if (c == 0)
            signalNotEmpty();
    }
```

**2.offer()方法**

```java
public boolean offer(E e) {
        if (e == null) throw new NullPointerException();
        final AtomicInteger count = this.count;
  		//如果元素个数 等于 最大值，直接返回false,添加失败
        if (count.get() == capacity)
            return false;
        int c = -1;
        Node<E> node = new Node<E>(e);
        final ReentrantLock putLock = this.putLock;
        putLock.lock();
        try {
            if (count.get() < capacity) {
                enqueue(node);
                c = count.getAndIncrement();
              	//元素添加成功，当前元素个数+1小于最大值，唤醒正在等待添加元素线程
                if (c + 1 < capacity)
                    notFull.signal();
            }
        } finally {
            putLock.unlock();
        }
        if (c == 0)
            signalNotEmpty();
        return c >= 0;
    }
```

3.poll(),take()区别

```java
public E take() throws InterruptedException {
        E x;
        int c = -1;
        final AtomicInteger count = this.count;
        final ReentrantLock takeLock = this.takeLock;
        takeLock.lockInterruptibly();
        try {
          	//如果元素个数等于0，阻塞获取元素的线程
            while (count.get() == 0) {
                notEmpty.await();
            }
            x = dequeue();
            c = count.getAndDecrement();
          	// 如果元素个数大于1，唤醒获取元素线程
            if (c > 1)
                notEmpty.signal();
        } finally {
            takeLock.unlock();
        }
        if (c == capacity)
            signalNotFull();
        return x;
    }
public E poll() {
        final AtomicInteger count = this.count;
  		//元素为空，直接返回null;
        if (count.get() == 0)
            return null;
        E x = null;
        int c = -1;
        final ReentrantLock takeLock = this.takeLock;
        takeLock.lock();
        try {
            if (count.get() > 0) {
                x = dequeue();
                c = count.getAndDecrement();
              // 如果元素个数大于1，唤醒获取元素线程
                if (c > 1)
                    notEmpty.signal();
            }
        } finally {
            takeLock.unlock();
        }
        if (c == capacity)
            signalNotFull();
        return x;
    }
```

**总结**

1.LinkedBlockQueue阻塞队列底层使用链表保存元素，默认大小为Integer.MAX_VALUE,可在构造函数中初始化大小。

2.LinkedBlockQueue添加和获取元素分别使用不同的同步锁。

3.put方法添加元素如果元素个数等于最大值，会将当前添加元素现场挂起，当当前元素个数+1小于最大值时，会唤醒等待中的添加元素线程，而offer方法则当元素个数等于最大值时直接返回添加失败，当当前元素个数+1小于最大值是，同样会唤醒等待中的线程。

4.poll方法获取元素，元素为空时直接返回，元素个数大于0时返回元素，同时个数减1大于0时，唤醒等待获取元素的线程，take方法获取元素，如果元素为空，则阻塞获取线程，统一元素个数大于0时返回元素，元素个数减1大于0时，唤醒等待获取元素的线程。

**ArrayBlockQueue和LinkedBlockQueue比较**

1.ArrayBlockQueue底层使用的是数组存值，数组大小在构造函数中初始化，LinkedBlockQueue使用链表，链表大小默认Integer.MAX_VALUE，可以在构造函数中初始化。

2.ArrayBlockQueue获取元素、添加元素使用的都是一把ReentrantLock同步锁，LinkedBlockQueue获取和添加有各自的takeLock和pollLock两把同步锁。

3.ArrayBlockQueue因为限定了底层数组的大小，所以存取操作元素的复杂度都是01，而LinkedBlockQueue需要维护next。

##### **DelayedQueue**

**`DeayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。`**DelayedQueue是一个没有大小限制的队列，因此网队列中插入数据的操作永远不会被阻塞，而只有获取数据的操作会被阻塞。

**DelayedQueue的延时策略可以总结为：**

1.存储元素必须实现Delayed接口

2.内部有一个ReentrantLock保证线程安全

3.使用优先级队列PriorityQueue实现元素存储

4.持有一个优化内部阻塞通知的线程leader

5.用于实现阻塞的CONDITION对象

**关于Delayed和PriorityQueue：**

Delayed是一个具有过期时间的元素类型

PriorityQueue是二叉堆实现的，根据队列里元素的某些属性排序的优先级队列，内部持有一个比较器Comparator

```java
//锁
private final transient ReentrantLock lock =new ReentrantLock();

//内部使用PriorityQueue储存元素
private final PriorityQueue<E> q = new PriorityQueue<E>();

//等待获取队列元素的线程
private Thread leader = null ;

//当一个新任务在队列的头部可用，获取新线程可能需要成为leader时，唤醒等待条件
private final Condition available = lock.newCondition();
```

leader是等待获取队列头元素的线程，应用主从式设计减少不必要的等待。当一个线程为leader是，它只会等待下一个延迟届期，但是其他线程的等待是不确定的，在take()或poll()获取数据返回钱，leader线程必须唤醒其他等待线程，除非其他线程在这期间变成leader。如果队列头被一个有这更快过期时间的元素替换掉，leader将会设置为null而失效，并唤醒其他等待线程（不一定是当前leader线程）。所以等待线程在等待期间必须时刻准备获取或失去leader权限。

**DelayQueue使用场景较少，但是都相当巧妙，常见的例子如：使用一个DelayQueue来管理一个超时未响应的连接队列。**

##### **PriorityBlockingQueue**

   基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），**但是需要注意的是PriorityBlockingQueue并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。**因此使用的时候要特别注意。生产者生产数据的速度绝对不能快于消费这消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内空间。在实现PriorityBlockingQueue时，**内部控制线程同步 锁采用的是公平锁。**

核心参数

```java
//默认容量
private static final int DEFAULT_INITIAL_CAPACITY =11;
//数组最大长度
private static dinal int MAX_ARRAY_SIZE =Integer.MAX_VALUE - 8;
//内部存储元素的数组，基于二叉堆实现
private transient Object [] queue;

//同步锁
private final ReentrantLock lock;

private final Condition notEmpty;

//初始0为可获取状态，用于控制扩容操作
private transient volatile int allocationSpinLock;
//比较器
private transient Comparator<? super E? comparator;
//内部PriorityQueue引用，用于兼容序列号
private PriorityQueue<E> q;
```

PriorityBlockingQueue（后称PBQ）的数据由内部的一个 Object 数组(`queue`)存储，这个数组本质上是一个**二叉堆**：

![img](https://raw.githubusercontent.com/ExplorerMan9527/image/master/%E4%BA%8C%E5%8F%89%E5%A0%86.png)

**二叉堆**是一种特殊的堆，二叉堆是完全二叉树或近似完全二叉树。二叉堆满足堆特性：父节点的键值总是与任何一个子节点的键值保持固定的序关系，且每个节点的子节点也都是一个二叉堆。

当父节点的键值总算大于或等于任何一个子节点的键值时为**最大堆**。当父节点的键值总算小于或等于任何一个子节点的键值时为**最小堆**。

二叉堆一般用数组来表示。如果跟节点在数组中的位置是1，第n个位置的子节点分别在2n和2n+1。因此，第一个位置的子节点在2和3，第2个位置的子节点在4和5。以此类推。这种基于1的数组储存方式便于寻找父节点和子节点。如果存储数组的下标基于0，那么下标为i的节点的子节点是2n+1与2（n+1）；其父节点的下标是（n-1）/2，PriorityBlockingQueue中使用的就是基于0下标的二叉堆。

offer(E e)方法

```java
//入队
public boolean offer(E e) {
    if (e == null)
        throw new NullPointerException();
    final ReentrantLock lock = this.lock;
    lock.lock();
    int n, cap;
    Object[] array;
    while ((n = size) >= (cap = (array = queue).length))
        //队列扩容
        tryGrow(array, cap);
    try {
        Comparator<? super E> cmp = comparator;
        //找到合适位置插入元素
        if (cmp == null)
            siftUpComparable(n, e, array);
        else
            siftUpUsingComparator(n, e, array, cmp);
        size = n + 1;
        notEmpty.signal();
    } finally {
        lock.unlock();
    }
    return true;
}
```

**数组的扩容**

tryGrow()方法进行扩容

PBQ的扩容说明：当队列元素大于等于数组的长度时，会触发扩容操作，扩容是由单线程完成的。如果数组长度cap小于64.扩容长度为2*（cap+1）；否则扩容长度为原来的1.5倍，tryGrow()源码：

```java
private void tryGrow(Object[] array, int oldCap) {
    lock.unlock(); // must release and then re-acquire main lock
    Object[] newArray = null;
    if (allocationSpinLock == 0 &&
        UNSAFE.compareAndSwapInt(this, allocationSpinLockOffset,
                                 0, 1)) {
        try {
            //计算新的数组容量（1.5*cap或2*(cap+1)）
            int newCap = oldCap + ((oldCap < 64) ?
                                   (oldCap + 2) : // grow faster if small
                                   (oldCap >> 1));
            if (newCap - MAX_ARRAY_SIZE > 0) {    // possible overflow
                int minCap = oldCap + 1;
                if (minCap < 0 || minCap > MAX_ARRAY_SIZE)
                    throw new OutOfMemoryError();
                newCap = MAX_ARRAY_SIZE;
            }
            if (newCap > oldCap && queue == array)
                newArray = new Object[newCap];
        } finally {
            allocationSpinLock = 0;
        }
    }
    //如果有其他线程已经在进行扩容操作，当前线程让出执行时间片
    if (newArray == null) // back off if another thread is allocating
        Thread.yield();
    lock.lock();
    if (newArray != null && queue == array) {
        queue = newArray;
        System.arraycopy(array, 0, newArray, 0, oldCap);
    }
}
```

**插入元素的优先级**

siftUpComparable()he siftUpUsingComparator(),由于队列中的元素都是有优先级（基于comparator排序）的，所以如果有新元素进来不会像其他队列一样直接放在队列尾部，而是通过这两个方法找到新增元素在队列中的排序位置然后插入，源码：

```java
//在k位置插入元素x，从父节点开始向上找到合适位置，保持二元堆的性质不变
private static <T> void siftUpComparable(int k, T x, Object[] array) {
    Comparable<? super T> key = (Comparable<? super T>) x;
    while (k > 0) {
        //从父节点开始向上查找，并保持二叉堆性质
        int parent = (k - 1) >>> 1;
        Object e = array[parent];
        if (key.compareTo((T) e) >= 0)
            break;//找到合适位置，跳出循环
        array[k] = e;
        k = parent;
    }
    array[k] = key;
}
//自定义Comparator版本的siftUpComparable
private static <T> void siftUpUsingComparator(int k, T x, Object[] array,
                                   Comparator<? super T> cmp) {
    while (k > 0) {
        //从父节点开始向上查找，并保持二叉堆性质
        int parent = (k - 1) >>> 1;
        Object e = array[parent];
        if (cmp.compare(x, (T) e) >= 0)
            break;//找到合适位置，跳出循环
        array[k] = e;
        k = parent;
    }
    array[k] = x;
}
```

**出列poll()方法**

```java
//出列
public E poll() {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        return dequeue();
    } finally {
        lock.unlock();
    }
}
private E dequeue() {
    int n = size - 1;
    if (n < 0)
        return null;
    else {
        Object[] array = queue;
        E result = (E) array[0];//第一个元素，即出列元素
        E x = (E) array[n];//最后一个元素
        array[n] = null;
        Comparator<? super E> cmp = comparator;
        //重构二叉堆
        if (cmp == null)
            siftDownComparable(0, x, array, n);
        else
            siftDownUsingComparator(0, x, array, n, cmp);
        size = n;
        return result;
    }
}
```

在出列操作时，首先移除数组的最后一个元素，然后调用siftDownComparable或siftDownUsingComparator方法进行二叉堆的重组，最后返回队列的第一个元素。

PBQ的出列本质上是删除二叉堆的根节点，然后把堆存储的最后那个节点移到填在节点处，再从上而下调整父节点与它的子节点。

##### **LinkedBlockingDueue**

LinkedBlockingDueues 是基于一个双向的链表，可以先进先出（队列），也可以先进后出（栈），不允许插入null，基本原理和方法都与LinkedBlockQueue差不多。

LinkedBlockQueue与LinkedBlockingDueue对比，LinkedBlockingDueue的线程安全以及阻塞等待的实现基本没有区别，两个阻塞队列基本可以通用（LinkedBlockingDueue作用栈时除外）。两个队列基本上只有两点不同：**一个是底层数据结构的细微区别，LinkedBlockingQueue是单向链表，而LinkedBlockingDueue则是双向链表；另一个是重入锁的使用有些区别，LinkedBlockingDueue不论出入队列使用的都是用一个锁对象，LinkedBlockingQueue的出入队锁是分开的**。

##### LinkedTransferQueue

LinkedTransferQueue是一个由链表结构组成的**无界阻塞**TrabsferQueue队列，相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和tranfer方法。

LinkedTransferQueue采用一种**预占模式**，意思就是**消费者线程取元素时，如果队列不为空，则直接取走数据，若队列为空，那就生成一个节点（节点元素为null）入队，然后消费者线程被等待在这个节点上，后面生产者线程入队时发现有一个元素为null节点时，生产者线程就不入队了，直接将元素填充到该节点，并唤醒该节点等待的线程，被唤醒的消费者现场取走元素，从调用的方法返回**，我们称这种节点操作为“匹配”方式。

LinkedTransferQueue是ConcurrentLinkedQueue、SynchronousQueue（公平模式下转交元素）、LinkedBlockingQueue（阻塞Queue的基本方法）的超集。而且LinkedTransferQueue更好用，因为它不仅仅综合了这几个类的功能，同时也提供了更高效的实现。

xfer的主要过程如下图所示：

![img](https://img-blog.csdn.net/20180607153737276?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjkzNTY0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

和SynchronousQueue相比，LinkedTransferQueue多了一个可以存储的队列，与LinkedBlockingQueue相比，LinkedTransferQueue多了直接传递元素，少了用锁来同步。

### 线程池

##### **为什么使用线程池** 

多线程的情况下确实可以最大限度发挥多核处理器的计算能力，提高系统的吞吐量和性能。但是如果随意使用线程，对系统的性能反而有不利影响。

##### **什么时候使用线程池**

假设一个服务器完成一项任务所需的时间为：T1创建线程时间，T2在线程中执行任务的时间，T3销毁线程的时间。 如果：T1+T3 远大于T2，则可以采用线程池，提高服务器性能。

**常用线程池类型**

基础线程池 ThreadPoolExecutor

延时任务线程池 ScheduledThreadPoolExecutor

分治线程池 ForkJoinPool

##### **线程池架构介绍**

**Executor** ：线程池的最上层接口，提供了任务提交的execute（Runnable command）方法

**ExecutorService** ：提供线程池管理的上层接口，继承了Executor接口，补充了池销毁，任务提交，异步任务提交。

**ScheduledExecutorService** ：提供任务定时或周期执行方法的ExecutorService。

**AbstractExecutorService**：为ExecutorService的任务提交方法提供了默认实现。

**ThreadPoolExecutor**：线程池类，提供线程和任务的调度策略。

**ScheduledThreadPoolExecutor**：属于线程池的一种，它可以允许任务延迟或周期执行，类似java的timer。

**ForkJoinPool**：JDK1.7加入的成员，也是线程池的一种，只允许执行ForkJoinTask（抽象基类）任务，它是为那些能够被递归地拆解成子任务的工作类型量身设计的。其目的在于能够使用所有可用的运算资源来提升应用性能。

**Executors**：创建各种线程池的工具类。

##### **线程池状态**

回顾线程的五种状态：

```java
public enum State {
 //创建状态
   	New; 
 //准备就绪状态
    Runnable;
 //阻塞状态 挂起状态比如等待synchronized同步锁
    Blocked;
 //等待状态当线程调用wait()/join()/LockSupport.park()不加超时之后的状态
  	Waiting;
 //LockSupport.parkNanos(等待时间)/LockSupport.parkUntil(等待时间)方法之后所的状态
    Timed_Waiting;
 //线程死亡状态
    Terminated;
}
```

###### **`1.线程池状态`**

```java
private static final int RUNNING    = -1 << COUNT_BITS;
private static final int SHUTDOWN   =  0 << COUNT_BITS;
private static final int STOP       =  1 << COUNT_BITS;
private static final int TIDYING    =  2 << COUNT_BITS;
private static final int TERMINATED =  3 << COUNT_BITS;
```

- RUNNING : 处于running状态的线程池能够接收新任务，以及对新添加的任务进行处理。
- SHUTDOWN ： 处于shutdown状态的线程池不可以接收新任务，但是可以对已添加的任务进行处理。
- STOP ：处于stop状态的线程池不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。
- TIDYING : 当所有的任务已终止，ctl记录的“任务数量”为0，线程池会变为tidying状态时，会执行构造函数terminated().terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为tidying时，进行相应处理；可以通过重载terminated()函数来实现。
- TREMINATED ： 线程池彻底终止的状态。

###### **`2.线程池参数`**

**corePoolSize**

线程池中核心线程的数量。当提交一个任务时，线程池会建一个线程来执行任务直到当前线程数等于corePoolSize。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。

**maximunmPoolSize**

线程池中允许最大线程数。线程池的阻塞队列满了之后，还有任务提交，如果当前线程数小于maxximumPoolSize，则会新建线程来执行任务。注意如果使用的是无界队列，该参数也就没有什么效果了。

**keepAliveTime**

线程空闲的时间。线程的创建和销毁都是需要代价的。线程执行完任务后不会立即销毁，而是继续存活一段时间：keepAliveTime。默认情况下，只有在线程数大于corePoolSize时才会生效。

**unit**

keepAliveTime的单位。TimeUnit

**workQueue**

用来保存等待执行的任务的阻塞队列，等待任务必须实现Runnable接口。可以选择已下几种队列：

- ArrayBlockingQueu：基于数组结构的有界阻塞队列，FIFO
- LinkedBlockingQueue：基于链表结构的有界阻塞队列，FIFO
- synchronousQueue：不存储元素的阻塞队列，每个插入操作都必须等待一个移除操作，每个移除也要有一个插入的操作。
- PriorityBlockingQueue：具有优先界别的阻塞队列。

**ThreadFactory**

用于设置创建线程的工厂。该对象可以通过Executors.defaultThreadFactory(),

###### **`3.创建线程池`**

1.**newCachaedThreadPool**创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收（重复使用线程），则新建线程。这种类型的线程池特点是：

- 工作线程的创建数量几乎没有限制（其实也是有限制的，数目为Integer.MAX_VALUE）,这样可灵活的往线程池中添加线程。
- 如果长时间没有往线程池中提交任务，即线程空闲了指定的时间（默认为一分钟），则该线程将自动终止。终止后，如果你又提交了新的任务，则线程池会重新创建一个工作线程。
- 在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有可能会造成系统瘫痪。

```java
 ExecutorService cachedThreadPool = Executors.newCachedThreadPool();  
```

2.**newFixedThreadPool**创建一个指定工作线程数量的线程池。每当提交一个任务就会创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中，FixedThreadPool是一个典型且优秀的线程池，具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有任何运行任务时，他不会释放工作线程，还会占用一定的系统资源。

```java
ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);
```

3.**newSingleThreadExecutor**创建一个单线程化的Executor，即值创建唯一的工作线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定的顺序（先进先出FIFO，后进先出LIFO ，优先级）执行。如果这个线程异常结束，会有另一个取代他，保证顺序执行。单工作线程最大的特点就是保证顺序的执行各个任务，并且在任意给定的时间不会有多个线程活动。

```java
ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
```

**4.newScheduleThreadPool**创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。

```
ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);
```

以上几种创建线程池的方式，都是通过newThreadPoolExecutor()来创建的，所以在我们开发中，也可以自己通过newThreadPoolExecutor创建线程池，并且自己指定创建线程池所需的所有参数。

```java
ExecutorService executor = new ThreadPoolExecutor(10, 10,60L, TimeUnit.SECONDS,new ArrayBlockingQueue(10));
```

###### **`4.线程池任务提交`**

**1.execute方法**

```java
public void execute(Runnable command) {
        if (command == null)
        int c = ctl.get();
        // 小于核心线程数
        if (workerCountOf(c) < corePoolSize) {
            //创建线程，执行任务
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        //大于核心线程数，则放入队列
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            //如果线程池不在运行中则移除任务，调用拒绝策略
            if (!isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        //如果，任务队列添加失败，并且线程数大于等于最大允许线程数，则调用拒绝策略
        else if (!addWorker(command, false))
            reject(command);
    }
```

说明：拒绝策略一共有以下四种

1.AbortPolicy：直接抛出异常，默认策略；

2.CallerRunsPolicy ：用调用者所在的线程来执行任务；

3.DiscardOldestPolicy: 丢弃阻塞队列中靠最前的任务，并执行当前任务；

4.DiscardPolicy ： 直接丢弃任务；

**2.submit方法**

submit()，提交一个线程任务，有返回值。
 submit(Callable<T> task)能获取到它的返回值，通过future.get()获取（阻塞直到任务执行完）。一般使用FutureTask+Callable配合使用（IntentService中有体现）。

submit(Runnable task, T result)能通过传入的载体result间接获得线程的返回值。
 submit(Runnable task)则是没有返回值的，就算获取它的返回值也是null。

Future.get方法会使取结果的线程进入阻塞状态，知道线程执行完成之后，唤醒取结果的线程，然后返回结果。

###### **`5.线程池流程`**

![img](https://upload-images.jianshu.io/upload_images/6024478-88ee7b20f8f45825.png?imageMogr2/auto-orient/strip|imageView2/2/w/937/format/webp)

**线程池为什么需要使用（阻塞）队列？**

1、因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换。

另外回到了非线程池缺点中的第1点：
 2、创建线程池的消耗较高。或者下面这个网上并不高明的回答：
 2、线程池创建线程需要获取mainlock这个全局锁，影响并发效率，阻塞队列可以很好的缓冲。

**线程池为什么要使用阻塞队列而不使用非阻塞队列？**

阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程，使得线程进入wait状态，释放cpu资源。
 当队列中有任务时才唤醒对应线程从队列中取出消息进行执行。
 使得在线程不至于一直占用cpu资源。

（线程执行完任务后通过循环再次从任务队列中取出任务进行执行，代码片段如下
 while (task != null || (task = getTask()) != null) {}）。

**如何配置线程池**

CPU密集型任务
 尽量使用较小的线程池，一般为CPU核心数+1。 因为CPU密集型任务使得CPU使用率很高，若开过多的线程数，会造成CPU过度切换。

IO密集型任务
 可以使用稍大的线程池，一般为2*CPU核心数。 IO密集型任务CPU使用率并不高，因此可以让CPU在等待IO的时候有其他线程去处理别的任务，充分利用CPU时间。

混合型任务
 可以将任务分成IO密集型和CPU密集型任务，然后分别用不同的线程池去处理。 只要分完之后两个任务的执行时间相差不大，那么就会比串行执行来的高效。
 因为如果划分之后两个任务执行时间有数据级的差距，那么拆分没有意义。
 因为先执行完的任务就要等后执行完的任务，最终的时间仍然取决于后执行完的任务，而且还要加上任务拆分与合并的开销，得不偿失。

**java中提供的线程池**

Executors类提供了4种不同的线程池：newCachedThreadPool, newFixedThreadPool, newScheduledThreadPool, newSingleThreadExecutor



![img](https:////upload-images.jianshu.io/upload_images/6024478-9e47d2796c8ab1aa.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

java线程池对比

1、newCachedThreadPool：用来创建一个可以无限扩大的线程池，适用于负载较轻的场景，执行短期异步任务。（可以使得任务快速得到执行，因为任务时间执行短，可以很快结束，也不会造成cpu过度切换）

2、newFixedThreadPool：创建一个固定大小的线程池，因为采用无界的阻塞队列，所以实际线程数量永远不会变化，适用于负载较重的场景，对当前线程数量进行限制。（保证线程数可控，不会造成线程过多，导致系统负载更为严重）

3、newSingleThreadExecutor：创建一个单线程的线程池，适用于需要保证顺序执行各个任务。

4、newScheduledThreadPool：适用于执行延时或者周期性任务。



# Redis

### 第一部分简单动态字符串



​	Redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组，简称C字符串），而是自己构建了一种名为简单动态字符串（simple dynamic String  SDS）的抽象类型，并使用SDS用作Redis的默认字符串表示。在redis的数据库里面，包含字符串值的键值对在底层都是由SDS实现的。

#### SDS的定义

SDS属性：

```
struct  sdshdr {

	int len; //记录SDS所保存字符串的长度
	
	int free; //记录buf数组中未使用字节的数量

	char buf []; //自己数组，用于保存字符串

}
```

**SDS遵循C字符串以空字符结尾的惯例**，保存空字符的1字节空间不计算在SDS的len属性里面，并且为空字符额外分配了1字节空间，和添加空字符到字符串末尾这些操作都是由SDS函数自动完成的，**遵循空字符结尾的好处是SDS可以直接重用一部分C字符串函数库里面的函数。**

#### SDS与C字符串的区别

​	 C语言使用长度为N+1的字符数组来表示长度为N的字符串，并且字符串数组的最后一个元素总是空字符串‘\0’。C语言使用的这种简单的字符串表示方式，并不能满足Redis对字符串在安全性、效率以及功能方面的要求。

##### **1.常数复杂度获取字符串长度**

​	因为C字符串不能记录自身长度信息，在获取长度的时候，必须遍历整个字符串，对每个字符进行计数，直到遇到末尾的空字符为止，这个操作的负责度为0(N)。而SDS在len属性中记录了本身长度所以获取长度复杂度仅为0(1)。设置和更新SDS长度的工作都是由SDS的API在执行时自动完成的，不需要手动修改。

##### **2.杜绝缓冲区溢出**

​	除了获取字符串长度复杂度高之外，C字符串不记录自身长度带来的另个一问题就是容易造成缓冲区溢出。例如：在进行字符串拼接时，因为C字符串不记录自身长度所以在执行时假设分配足够多的内存可以容纳新拼接的字符串，但是如果这个假设不成立时，就会产生缓冲区溢出。

​	和C字符不同，SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性：**当SDSAPI需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足，API会自动将SDS的空间扩展至执行修改所需的大小，这样也就不会出现缓冲区溢出的问题了**。

##### **3.减少修改字符串时带来的内存分配次数**

​	因为C字符串不记录自身长度，在底层总是一个N+1个字符长的数组。因为C字符串的长度和底层数组的长度之间存在这这种关联性，所以每次增长或者缩短一个C字符串，程序总要对这个C字符串进行一次内存重分配操作。

​	为了避免C字符串的这种缺陷，SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：在SDS中，buf数组长度不一定就是字符数量加一，数组里面可以包含为使用的字节，而这些字节的数量就由SDS的free属性记录。

通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。

- **空间预分配**

  空间预分配是用于优化SDS的字符增长操作：当SDS的Api对一个SDs进行修改并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所需的空间，还会分配额外的未使用空间。

  - 如果对SDS进行修改之后，SDS的长度（也就是len属性的值）将小于1MB，那么分配的大小就是和len值同样大小的未使用空间，这时SDS的len值和free的值是相同的。即使用空间和为使用空间相同（len会比free多一个空字节）。
  - 如果SDS修改后长度大于1MB，程序就会分配1MB的未使用空间，即free=1MB。

​        通过空间预分配策略，Redis可以减少连续执行字符串增长所需的内存重分配次数。在扩展SDS空间之前，SDS API会先检查未使用空间是否足够，如果够，直接使用未使用的空间，不需要重新分配内存。这样如果SDS连续增长N次字符串所需的内存重分配次数必定N次降低为最多N次。

- **惰性空间释放**

  惰性空间释放策略用于优化SDS的字符串缩减操作：当SDS的APi需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是用free记录下这些字节的数量，等待后续的使用。**即缩短的字节空间全部加入free未使用空间中，不对原有内存空间大小做重分配**。

##### **4.二进制安全**

​	C字符串中的字符必须符合某种编码，并且除了字符串的末尾之外，字符串里面不能包含空字符串，否则最先被程序读认的空字符会被误认是字符串结尾，这样就限制是的C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据。

​	虽然数据库一般用户保存文本数据，但使用数据库来保存二进制数据的场景也不少见，因此，为了确保Redis可以适用于各种不同的使用场景，SDS的API都是二进制安全的（binary-safe），所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，它被读取是就是什么样。

​	这也是我们将SDS的buf属性称为字节数组的原因———Redis不是用这个数组来保存字符，而是用它来保存一些列二进制数据。

##### **5.兼容部分C字符串函数**

​	虽然SDS的API都是二进制安全的，但它们一样遵循C字符串以空字符结尾的惯例：这些API总会将SDS保存的数据末尾设置为空字符，在分配空间时多分配一个字节来容纳这个空字符，这样做主要是为了让那些保存文本数据的SDS可以重用一部分<String.h>库定义的函数。**通过遵循C字符串以空字符结尾，SDS可以在有需要时重用<string.h>函数库，从而避免了不必要的代码重复**。

#### 链表

​	链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活的调整链表的长度。

​	作为一种常用数据结构，链表内置在很多高级的编程语言里面，因为Redis使用的C语言并没有内置这种数据结构，所以redis构建了自己的链表实现。

​	链表在Redis中的应用非常广泛，比如列表键的底层实现之一就是链表。当一个列表键板含量数量比较多的元素，或者列表中包含的元素都是比较长的字符串，Redis就会使用链表作为列表键的底层实现。

##### 链表和链表节点的实现

每个链表节点使用一个adlist.h/listNode结构来表示：

```
typedef struct listNode{
	//前置节点
    struct listNode * prev;
    //后置节点
    struct listNode * next;
    //节点的值
    void * value;
}listNode；
```

多个listNode可以通过prev和next指针组成双端链表：

![1585639701564](C:\Users\Administrator.2013-20171123NU\AppData\Roaming\Typora\typora-user-images\1585639701564.png)

​	虽然仅仅使用多个listNode结构就可以组成链表，但使用adlist.h/list来持有链表的话操作起来会更方便：

```
typedef struct list {
    //表头节点
    listNode * head ;
    //表尾节点
    listNode * tail ;
    //链表所包含的节点数量
    unsigned long len;
    //节点值复制函数
    void *(*dup)(void * ptr);
    //节点值释放函数
    void (*free)(void *ptr);
    //节点值对比函数
    int (*match)(void *ptr,woid *key);
}
```

list结构为链表提供了表头指针head、表尾指针tail，以及链表长度计数器len，而dup、free和match成员则是用于实现多态链表所需的类型特定函数：

- dup函数用于复制链表节点所保存的值；
- free函数用于释放链表节点锁保存的值；
- match函数则用于对比和三个listNode结构组成的链表。

![1585641503999](C:\Users\Administrator.2013-20171123NU\AppData\Roaming\Typora\typora-user-images\1585641503999.png)

Redis的链表实现特性可以总结如下：

- 双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是0（1）。
- 无环：表头节点的prev指针和表尾节点的next指针都指向null，对链表的访问以null为终点。
- 带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点复杂度为0（1）。
- 带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为0（1）。
- 多态：链表节点使用void* 指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点设置类型特点函数，所以链表可以用于保存各种不同类型的值。

#### 字典

​	字典，又称为符号表（symbol table）、关联数组（associative array）或映射（map），是一种用于保存键值对（key-value pair）的抽象数据结构。

​	在字典中，一个键（key）可以和一个值（value）进行关联（或者说将键映射为值），这些关联的键和值就称为**键值对**。

​	字典中的每个**键都是独一无二的**，程序可以在字典中根据键查找与之关联的值，或者通过键来更新值，又或者是根据键来删除整个键值对，等等。

##### 字典的实现

​	Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典的一个键值对。

##### **哈希表**

Redis字典所使用的哈希表由dict.h/dictht结构定义：

```c
typedef struct dictht{
    //哈希表数组
    diceEntity **table;
    //哈希表大小
    unsigned long size;
    //哈希表大小掩码，用来计算索引值 总算等于size-1
    unsigned long sizemask;
    //该哈希表已有节点的数量
    unsigned long used;
}dictht;
```

table属性是一个数组，数组中的每个元素都是一个指向dict.h/dictEntry结构的指针，每个dictEntry结构保存值一个键值对。size属性记录了哈希表的大小，也即是table数组的大小，而used属性则记录了哈希表目前已有节点（键值对）的数量。sizemask属性的值都是等于size-1，这个属性和哈希值一起决定一个键应该被放到table数组的哪个索引上面。

![1585705841991](C:\Users\Administrator.2013-20171123NU\AppData\Roaming\Typora\typora-user-images\1585705841991.png)

##### **哈希表节点**

哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对：

```c
typedef struct dictEntry{
    //键
    void *key;
    //值
    union{
        void *val;
        uint64_tu64;
        int64_ts64;
    }v;
    //指向下一个哈希表节点，形成链表
    struct dictEntry *next;
    
}dictEntry;
```

​	key属性保存着键值对中的键，而v属性则保存着键值对中的值，其中键值对的值可以是一个指针，或者是一个unit64_t整数，或者是一个int64_t整数。

​	next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一起，来解决键冲突的问题。

![1585711437487](C:\Users\Administrator.2013-20171123NU\AppData\Roaming\Typora\typora-user-images\1585711437487.png)

#####  **字典**

redis中的字典由dict.h/dict结构表示：

```C
typedef struct dict{
    //类型特定函数
    dictType *type;
    //私有数据
    void *privdata;
    //哈希表
    dictht ht[2];
    
    //rehash引索
    //当rehash不再进行时，值为-1
    int trehashidx;
}dict；
```

type属性和privdata属性是针对不同类型的键值对，为创建多态字典表而设置的：

- type属性是一个指向dicType结构的指针，每个dicType结构保存了一簇用于操作特定类型键值对 的函数，Redis会为用途不同的字典设置不同的类型特定函数。
- 而privdata属性则保持了需要传给那些类型特定函数的可选参数。

```c
typedef struct dictType {
    //
    unsigned int (*hashFunction)(const coid * key);
    //
    void *(*keyDup)(void *privdata,const void *key);
    //
    void *(*valDup)(void *privdata,const void *obj);
    //
    int (*keyCompare)(void *privdata, const void *key1,const void *key2);
    //
    void (*keyDestructor)(void *privdata, void *key);
    //
    void (*valDestructor)(void *privdata,void *obj);
}dicType;
```

ht属性是一个包含两个项的数组，数组中的每个项目都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。除了ht[1]之外，另一个和rehash有关的属性就是rehashidx，它记录了rehash目前的进度，如果目前没有在进行rehash，那么它的值为-1。

![1585791297654](C:\Users\Administrator.2013-20171123NU\AppData\Roaming\Typora\typora-user-images\1585791297654.png)

##### **哈希算法**

当要将一个新的键值对添加到字典里面时，程序需要**先根据键值对的键计算出哈希值和索引值，然后在根据索引值，将包含新键值对的哈希表节点放到哈希表数组指定的索引上面**。

Redis计算哈希值和索引值的方法：

```c
#使用字典设置的哈希函数，计算键key的哈希值
hash=dict -> type -> hashFunction(key);

#使用哈希表的sizemask属性和哈希值，计算出索引值
#根据情况不同，ht[x]可以是ht[0]或者ht[1]
index = hash & dict ->ht[x].sizemask;
```

![1585807890195](C:\Users\Administrator.2013-20171123NU\AppData\Roaming\Typora\typora-user-images\1585807890195.png)

当字典被用作数据库底层实现，或者哈希表键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。MurmuiHash2这种算法优点在于，**即使输入的键是有规律的，算法扔能给出一个很好的随机分布性，并且算法的计算速度也非常快**。

##### **解决键冲突**

 	当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时，称这些键发生了冲突（collision）。

​	Redis的哈希表使用**链地址法**（separate chaining）来解决键冲突，每个哈希表都有一个**next指针**，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这样就解决了键冲突问题。

##### **Rehash**

​	随着操作的不断执行，哈希表保存的键值对会逐渐地增多或减少，为了让哈希表的负载因子（load factor）维持一个合理范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展和收缩。

​	**扩展和收缩哈希表的工作可以通过执行rehash（重新散列）操作来完成**，Redis对字典的哈希表执行rehash的步骤：

- 为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，和ht[0]当前包含的键值对数量，即ht[0]的used属性值。如果执行的是扩展操作：那么ht[1]的大小为第一个等于ht[0].used*2的2n次方幂。如果执行的是收缩操作：ht[1]的大小为大于等于ht[0].used的2n次方幂。
- 将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。
- 当ht[0]的所有键值对都迁移到了ht[1]之后，会将ht[0]释放，然后把ht[1]设置为ht[0],然后在创建一个新的空白哈希表，为下一次rehash做准备。

##### **哈希表的扩展与收缩**

当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作：

- 服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，且哈希表的负载因子大于等于1。

- 服务器当前正在执行BGSAVE命令或者BGREWRITEAOF命令，且哈希表的负载影子大于等于5。

  根据命令是否正在执行，服务器执行扩展所需的负载因子并不同，这是因为在执行BGSAVE或BGREWRITEAOF命令的过程，Redis需要创建子进程，而大多数操作系统都是采用写时复制技术来优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而尽可能避免在子进程存在期间进行哈希表扩展操作，避免不必要的内存写入操作，最大限度节约内存。

  ​	另外，当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行收缩操作。

##### **渐进式rehash**

​	哈希表执行rehash动作并不是一次性、集中式完成的，而是分多次、渐进式低完成。这样的原因在于，如果哈希表有大量键值对时一次性执行rehash，庞大的计算量可能会当值服务器在一段时间内停止服务。

​	为了避免rehash对服务器性能造成影响，服务器不是一次性将ht[0]里面的所有键值对全部rehash到ht[1],而是分多次、渐进式地将ht[0]里面的键值对慢慢的rehash到ht[1]中。

1. 为ht[1]分配空间，让字典同事持有ht[0]和ht[1]两个哈希表。
2. 在字典中维持索引计数器变量rehashidx，并将它的设置为0，表示rehash工作正式开始。
3. 在rehash进行期间，每次对字典执行添加、删除、查找或更新操作时，程序除了执行指定的操作以外，还会将ht[0]哈希表在rehashidx索引上所有的键值对rehash到ht[1],当rehash完成后将rehashidx属性值加1。
4. 随着字典操作不断的执行，当ht[0]所有的键值对都被rehash到ht[1],这时rehashidx属性值会设为-1，表示rehash操作已经完成。

渐进式的好处在于使用了分而治之的方式，将rehash键值对所需的计量工作均摊到对字典的添加、删除、查找和更新操作上，避免了集中式rehash带来的庞大计算量。

#### 跳跃表

​	跳跃表是一种有序数据结构，通过在每个节点中维持多个指向其他节点的指针，达到快速访问节点的目的。

​	Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序结合中元素的成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。

​	和链表、字典等数据结构被广泛应用在Redis内部不同，Redis只在两个地方用到了跳跃表，一个是实现有序集合，另一个是在集群节点中用作内部数据结构。

##### 跳跃表的实现

​	跳跃表节点的实现由redis.h/zskiplistNode结构定义：

```c
typedef struct zskiplistNode{
    //层
    struct zskiplistLevel{
        //前进指针
        struct zskiplistNode *forward;
        //跨度
        unsigned int span;
    }level[];
    //后退指针
    struct zskiplistNode *backward;
    //分值
    double score;
    //成员对象
    robj *obj;
}zskiplistNode;
```

###### **层**

​	跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，层的数量越多，访问其他节点的数度就越快。

​	每次创建一个新跳跃表节点的时候，程序都根据幂次定律（power law，越大的数出现的概率越小）随机生产一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”。

![1586239912578](C:\Users\Administrator.2013-20171123NU\AppData\Roaming\Typora\typora-user-images\1586239912578.png)

###### 前进指针

​	每个层都有一个指向表尾方向的前进指针（level[i].forward）,用于从表头向表尾方向访问节点。如图：用虚线表示除了程序从表头向表尾方向，遍历跳跃表中所有节点路径：

![1586240444375](C:\Users\Administrator.2013-20171123NU\AppData\Roaming\Typora\typora-user-images\1586240444375.png)

1. 迭代程序首先访问跳跃表的第一个节点（表头），然后从第四层的前进指针移动到表中的第二个节点。
2. 在第二个节点时，程序沿着第二层的前进指针移动到表中的第三个节点。
3. 在第三个节点时，程序同样沿着第二层的前进指针移动到表中的第四个节点。
4. 当层序在次沿着第四个节点的前进指针移动时，它碰到一个NULL，程序知道这时已经的到达了跳跃表的表尾，于是结束这次遍历。

###### 跨度

​	层的跨度（level[i].span属性）用于记录两个节点之间的距离：

- 两个节点之间的跨度越大，他们相距得就越远。
- 指向NULL的所有前进指针的跨度都为0，因为它们没有连向任何节点。

跨度指的是跳跃表由头到尾直接两个节点之间的距离起始表头以0开始往后。

###### 后退指针

​	节点的后退指针（backward属性）用于从表尾向表头方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所有每次只能推到前一个节点。

###### 分值和成员

​	节点的分值（score）是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序。

​	节点的成员对象（obj）是一个指针，它只想一个字符串对象，保存着一个SDS值。

​	在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值是可以相同的：分值相同的节点，会按照成员对象在字典序由小到大进行排序。

##### 跳跃表

​	多个跳跃表节点就可以组成一个跳跃表，但通过使用一个zskiplist结构来持有这些节点，程序可以更方便地对整个跳跃表进行处理，例如快速访问跳跃表的表头节点和表尾节点，或者快速的获取跳跃表节点的数量（跳跃表的长度）。

zskiplist结构的定义：

```c
zskiplist struct zskiplist{
    //表头节点和表尾节点
    structz skiplistNode *header, *tail;
    //表节点数量
    unsigned long length;
    //表中层数最大的节点的层数
    int level;
}zskiplist;
```

![1586247126164](C:\Users\Administrator.2013-20171123NU\AppData\Roaming\Typora\typora-user-images\1586247126164.png)

​	header和tail指针分别 指向跳跃表的表头和表节点，通过两个指针程序可以快速定位表头节点和表尾节点。

​	通过使用length熟悉来记录节点的数量，程序可以直接获取到跳跃表的长度。

​	level属性则用于快速获取跳跃表中层高最大的那个节点的层数，表头节点的层高不计算在内。

